{
  "questions": [
    {
      "id": 1,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "Spring Framework에서 **IoC(Inversion of Control)**의 의미를 간단히 설명하세요.",
      "answer": "객체의 생성, 생명주기 관리, 의존성 설정을 개발자가 아닌 Spring IoC 컨테이너가 담당하는 것을 의미합니다.",
      "explanation": "IoC는 제어의 역전으로, 객체 간의 결합도를 낮추고 유연성을 높여줍니다."
    },
    {
      "id": 2,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "Spring Bean의 기본 스코프(scope)는 무엇입니까?",
      "choices": [
        "prototype",
        "request",
        "singleton",
        "session"
      ],
      "answer": "singleton",
      "explanation": "singleton은 Spring IoC 컨테이너당 하나의 객체만 생성되어 공유되는 기본 스코프입니다."
    },
    {
      "id": 3,
      "type": "descriptive",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "Spring에서 **DI(Dependency Injection)**를 구현하는 세 가지 주요 방법에 대해 설명하세요.",
      "answer": "1) **생성자 주입 (Constructor Injection)**: 생성자를 통해 의존성을 주입받으며 불변성 보장 및 순환 참조 방지에 가장 권장됩니다.\n2) **Setter 주입 (Setter Injection)**: Setter 메서드를 통해 의존성을 주입받으며 선택적 의존성에 사용됩니다.\n3) **필드 주입 (Field Injection)**: @Autowired를 필드에 직접 사용하여 주입하며 코드가 간결하지만 테스트 및 단일 책임 원칙에 불리하여 권장되지 않습니다.",
      "explanation": "생성자 주입이 가장 권장되는 방식입니다."
    },
    {
      "id": 4,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "advanced",
      "question": "Spring AOP에서 **Joint Point**와 **Pointcut**의 차이점을 설명하세요.",
      "answer": "Joint Point는 Advice가 적용될 수 있는 **모든 실행 가능한 지점** (메서드 실행, 필드 접근 등)이고, Pointcut은 Joint Point 중에서 실제로 Advice를 **적용할 대상을 선별**하는 표현식입니다.",
      "explanation": "Pointcut은 Joint Point의 부분집합으로 이해할 수 있습니다."
    },
    {
      "id": 5,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "다음 중 Spring Bean의 생명주기(Lifecycle) 초기화 단계 콜백 메서드 호출 순서가 **잘못된** 것은?",
      "choices": [
        "생성자 호출",
        "@PostConstruct 메서드",
        "InitializingBean.afterPropertiesSet()",
        "DisposableBean.destroy()"
      ],
      "answer": "DisposableBean.destroy()",
      "explanation": "DisposableBean.destroy()는 **소멸(Destruction)** 단계에서 호출되는 콜백이며, 초기화 단계에서는 호출되지 않습니다. 초기화 순서는 생성자 → @PostConstruct → InitializingBean.afterPropertiesSet() → 커스텀 init-method 순입니다."
    },
    {
      "id": 6,
      "type": "descriptive",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot의 **Auto Configuration (자동 설정)** 원리를 간단히 설명하세요.",
      "answer": "Spring Boot는 클래스패스에 존재하는 **Starter** 의존성과 **@Conditional** 애노테이션들을 사용하여 개발자가 별도로 설정하지 않아도 필요한 Bean 설정을 자동으로 등록합니다. 예를 들어, `spring-boot-starter-web`이 있으면 웹 관련 설정을 자동으로 합니다.",
      "explanation": "자동 설정 덕분에 설정 파일의 양이 대폭 줄어들고 개발 생산성이 향상됩니다."
    },
    {
      "id": 7,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "beginner",
      "question": "@SpringBootApplication 애노테이션이 포함하고 있지 **않은** 애노테이션은?",
      "choices": [
        "@Configuration",
        "@EnableAutoConfiguration",
        "@ComponentScan",
        "@Controller"
      ],
      "answer": "@Controller",
      "explanation": "@SpringBootApplication은 @Configuration, @EnableAutoConfiguration, @ComponentScan을 통합하지만, 특정 계층인 @Controller는 포함하지 않습니다."
    },
    {
      "id": 8,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot에서 외부 설정 파일의 우선순위가 가장 높은 것은 (명령줄 인수, 환경 변수, `application.properties` 중)?",
      "answer": "명령줄 인수 (Command Line Arguments)",
      "explanation": "외부 설정은 17단계의 우선순위를 가지며, 명령줄 인수가 가장 높은 우선순위를 가집니다. 이를 통해 애플리케이션 실행 시 설정을 쉽게 오버라이드할 수 있습니다."
    },
    {
      "id": 9,
      "type": "descriptive",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "@ConfigurationProperties와 @Value의 차이점과 사용 시나리오를 설명하세요.",
      "answer": "@Value는 개별 속성 하나를 주입받을 때 사용되며 SpEL 사용이 가능합니다. @ConfigurationProperties는 관련된 여러 속성을 하나의 **객체(POJO)**로 바인딩할 때 사용되며, 타입 안정성, 유효성 검증, IDE 자동 완성과 같은 이점을 제공합니다. 복잡한 설정을 구조화할 때는 후자가 적합합니다.",
      "explanation": "구조적인 설정을 관리할 때는 @ConfigurationProperties가 훨씬 유리합니다."
    },
    {
      "id": 10,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot Actuator의 기본 엔드포인트 중, 애플리케이션의 상태(UP/DOWN)를 확인하는 데 사용되는 것은?",
      "choices": [
        "/actuator/info",
        "/actuator/metrics",
        "/actuator/health",
        "/actuator/trace"
      ],
      "answer": "/actuator/health",
      "explanation": "/actuator/health 엔드포인트는 데이터베이스 연결, 디스크 공간 등 애플리케이션의 상태 정보를 제공합니다."
    },
    {
      "id": 11,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "Spring MVC에서 클라이언트의 HTTP 요청을 가장 먼저 받는 프런트 컨트롤러(Front Controller) 컴포넌트는 무엇입니까?",
      "answer": "DispatcherServlet",
      "explanation": "DispatcherServlet은 모든 요청을 받아 처리 흐름을 조정하는 Spring MVC의 핵심입니다."
    },
    {
      "id": 12,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "@RequestParam과 @PathVariable 중 URL 경로(/users/{id})에서 값을 추출하는 데 사용되는 애노테이션은?",
      "choices": [
        "@RequestParam",
        "@PathVariable",
        "@ModelAttribute",
        "@RequestBody"
      ],
      "answer": "@PathVariable",
      "explanation": "@PathVariable은 URL 템플릿의 변수 값을 추출하고, @RequestParam은 쿼리 스트링(?key=value)에서 값을 추출합니다."
    },
    {
      "id": 13,
      "type": "descriptive",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "@Controller와 @RestController의 차이점과 사용 목적을 설명하세요.",
      "answer": "**@Controller**는 주로 **View(화면)**를 반환하는 전통적인 MVC 패턴에 사용됩니다. **@RestController**는 @Controller에 **@ResponseBody**가 결합된 형태로, 메서드의 반환 값을 View 이름이 아닌 **JSON/XML 등의 데이터**로 직접 HTTP 응답 본문에 작성할 때 사용되며, 주로 **REST API** 서버 구축에 사용됩니다.",
      "explanation": "@RestController 덕분에 API 서버를 쉽게 구축할 수 있습니다."
    },
    {
      "id": 14,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "Spring MVC에서 `redirect:` 접두사를 사용하는 것과 사용하지 않는 것의 차이점(브라우저 동작 기준)을 설명하세요.",
      "answer": "redirect:를 사용하면 브라우저에게 새로운 URL로 **재요청(HTTP 302)** 하라고 응답합니다. 사용하지 않으면 DispatcherServlet이 View Resolver를 통해 **내부적으로** 뷰를 찾아 렌더링합니다.",
      "explanation": "redirect는 URL이 바뀌지만, 내부 포워딩은 URL이 바뀌지 않습니다."
    },
    {
      "id": 15,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "RESTful API에서 리소스 생성에 가장 적합한 HTTP 메서드는?",
      "choices": [
        "GET",
        "PUT",
        "POST",
        "DELETE"
      ],
      "answer": "POST",
      "explanation": "POST는 새로운 리소스를 생성할 때 사용되는 HTTP 메서드입니다."
    },
    {
      "id": 16,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "beginner",
      "question": "JPA(Java Persistence API)에서 영속성 컨텍스트 내에 엔티티를 관리하는 가장 기본적인 상태는 무엇입니까?",
      "answer": "Managed(관리)",
      "explanation": "엔티티의 상태는 New(비영속), Managed(영속), Detached(준영속), Removed(삭제) 네 가지가 있습니다."
    },
    {
      "id": 17,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "JPA에서 `EntityManager.persist()` 메서드를 호출할 때 엔티티의 상태 변화는?",
      "choices": [
        "Managed → Detached",
        "New → Managed",
        "Managed → New",
        "Detached → Managed"
      ],
      "answer": "New → Managed",
      "explanation": "persist()는 비영속 상태의 엔티티를 영속성 컨텍스트에 넣어 Managed(영속) 상태로 만듭니다."
    },
    {
      "id": 18,
      "type": "descriptive",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "JPA에서 **N+1 문제**가 발생하는 이유와 이를 해결하는 일반적인 방법 2가지를 설명하세요.",
      "answer": "N+1 문제는 연관된 엔티티를 조회할 때, 첫 번째 쿼리로 1개의 주 엔티티 목록을 가져온 후, 목록의 각 엔티티에 대해 다시 N개의 연관 엔티티 조회 쿼리가 실행되는 현상입니다. 해결 방법은 1) **Fetch Join** (JPQL 이용)으로 한 번의 쿼리로 연관 엔티티를 함께 가져오거나, 2) **@EntityGraph**를 사용하거나, 3) **@BatchSize**를 설정하여 N개의 쿼리를 IN 절을 사용하는 1개의 쿼리로 줄이는 방법이 있습니다.",
      "explanation": "N+1 문제를 해결하는 것은 JPA 성능 최적화의 핵심입니다."
    },
    {
      "id": 19,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "Spring Data JPA에서 쿼리 메서드를 정의할 때, 결과 목록을 페이징 처리하기 위해 메서드 파라미터로 받아야 하는 객체는 무엇입니까?",
      "answer": "Pageable",
      "explanation": "`Pageable` 객체는 페이지 번호, 페이지 크기, 정렬 조건을 포함합니다. 반환 타입은 보통 `Page<T>`입니다."
    },
    {
      "id": 20,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "beginner",
      "question": "JPA에서 엔티티 클래스를 테이블로 매핑하는 데 사용하는 애노테이션은?",
      "choices": [
        "@Table",
        "@Repository",
        "@Entity",
        "@Bean"
      ],
      "answer": "@Entity",
      "explanation": "@Entity는 해당 클래스가 JPA 엔티티이며 데이터베이스 테이블에 매핑됨을 나타냅니다."
    },
    {
      "id": 21,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "beginner",
      "question": "Spring Security에서 사용자 인증 정보를 담고 있는 핵심 인터페이스 2가지는?",
      "answer": "UserDetails (사용자 정보)와 Authentication (인증 객체)",
      "explanation": "Authentication 객체는 UserDetails를 포함하며, SecurityContextHolder에 저장됩니다."
    },
    {
      "id": 22,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 **CSRF** 공격을 방어하기 위해 사용하는 기본 메커니즘은?",
      "choices": [
        "JWT 사용",
        "URL 인코딩",
        "CSRF 토큰 사용",
        "Session ID 검증"
      ],
      "answer": "CSRF 토큰 사용",
      "explanation": "상태 변경 요청(POST, PUT, DELETE)에 고유한 CSRF 토큰을 포함시켜 요청의 유효성을 검증합니다."
    },
    {
      "id": 23,
      "type": "descriptive",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "Spring Security에서 **JWT(Json Web Token)** 기반 인증이 세션 기반 인증과 비교했을 때 가지는 주요 장점 2가지를 설명하세요.",
      "answer": "1) **Stateless(무상태)**: 서버가 인증 상태를 저장할 필요가 없어 서버 부하를 줄이고 수평 확장이 용이합니다.\n2) **모바일/분산 환경 적합**: 토큰 자체에 사용자 정보가 포함되어 있어 모바일 앱이나 마이크로서비스 환경에서 쉽게 인증 정보를 공유할 수 있습니다.",
      "explanation": "세션 기반은 서버에 상태를 저장하지만, JWT 기반은 클라이언트에 토큰을 저장합니다."
    },
    {
      "id": 24,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 권한을 체크할 때 `hasRole('ADMIN')`과 `hasAuthority('ROLE_ADMIN')`의 차이점은 무엇입47214니까?",
      "answer": "`hasRole()`은 내부적으로 권한 이름 앞에 **`ROLE_` 접두사를 자동으로 추가**하지만, `hasAuthority()`는 접두사 없이 **정확히 일치**하는 권한 이름을 사용합니다.",
      "explanation": "`hasAuthority()`가 더 유연하고 명시적인 권한 체크 방법입니다."
    },
    {
      "id": 25,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "beginner",
      "question": "Spring Security에서 HTTP 기본 인증(Basic Auth)을 활성화하는 가장 간단한 방법은?",
      "choices": [
        "WebSecurityConfigurerAdapter 구현",
        "설정 파일에서 username, password 설정",
        "HttpSecurity에 `.httpBasic()` 추가",
        "@EnableBasicAuth 애노테이션 사용"
      ],
      "answer": "HttpSecurity에 `.httpBasic()` 추가",
      "explanation": "Spring Security 설정 클래스에서 `HttpSecurity`를 구성할 때 `.httpBasic()`을 호출하여 기본 인증을 활성화할 수 있습니다."
    },
    {
      "id": 26,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "Spring에서 순환 의존성(Circular Dependency)이 발생했을 때 생성자 주입과 Setter 주입 중 어느 방식이 더 문제를 일으키기 쉬우며, 그 이유는 무엇입니까?",
      "answer": "**생성자 주입**이 더 문제를 일으키기 쉽습니다. Bean 생성 시점에 모든 의존성이 필요하기 때문에 무한 루프에 빠져 Bean 생성이 불가능해집니다.",
      "explanation": "Setter 주입은 객체 생성 후 의존성 주입이 일어나므로, `prototype` 스코프나 `@Lazy`를 사용하면 일시적으로 순환 참조를 허용할 수 있습니다."
    },
    {
      "id": 27,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "advanced",
      "question": "Spring AOP의 프록시 기반 구현에서, 타겟 객체가 인터페이스를 구현하지 않았을 때 사용되는 프록시 기술은?",
      "choices": [
        "JDK Dynamic Proxy",
        "CGLIB Proxy",
        "AspectJ Weaver",
        "ProxyFactoryBean"
      ],
      "answer": "CGLIB Proxy",
      "explanation": "JDK Dynamic Proxy는 인터페이스 기반 프록시를 생성하고, CGLIB는 클래스를 상속받아 프록시를 생성합니다. 인터페이스가 없으면 CGLIB가 사용됩니다."
    },
    {
      "id": 28,
      "type": "descriptive",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "BeanFactory와 ApplicationContext의 주요 차이점을 2가지 이상 설명하세요.",
      "answer": "1) **기능 차이**: ApplicationContext는 BeanFactory를 확장하여 AOP, 국제화(i18n), 이벤트 처리, 환경 추상화 등 **엔터프라이즈 기능**을 추가로 제공합니다.\n2) **로딩 시점**: BeanFactory는 Bean을 요청할 때(Lazy Loading) 로드하지만, ApplicationContext는 일반적으로 컨테이너 시작 시 모든 싱글톤 Bean을 미리 로드(Eager Loading)합니다.",
      "explanation": "ApplicationContext가 더 자주 사용되며 실무에 적합합니다."
    },
    {
      "id": 29,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "Spring에서 **@Autowired** 애노테이션으로 의존성을 주입할 때, 주입 대상이 여러 개일 경우 발생하는 문제를 해결하기 위한 애노테이션은?",
      "answer": "@Qualifier",
      "explanation": "@Qualifier는 특정 Bean ID를 지정하여 주입할 Bean을 명확하게 선택할 때 사용됩니다."
    },
    {
      "id": 30,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "다음 중 Spring에서 컴포넌트 스캔 대상에 포함되지 **않는** 애노테이션은?",
      "choices": [
        "@Service",
        "@Controller",
        "@Configuration",
        "@Value"
      ],
      "answer": "@Value",
      "explanation": "@Value는 외부 설정 값을 주입하는 데 사용되며, 컴포넌트 스캔의 대상이 되는 스테레오타입(Stereotype) 애노테이션이 아닙니다. @Component, @Service, @Controller, @Repository 등은 스캔 대상입니다."
    },
    {
      "id": 31,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "beginner",
      "question": "Spring Boot에서 애플리케이션의 설정 파일로 가장 일반적으로 사용되는 두 가지 파일 형식은 무엇입니까?",
      "answer": "application.properties와 application.yml",
      "explanation": "YAML 형식은 계층적인 구조를 제공하여 복잡한 설정을 구조화하기 편리합니다."
    },
    {
      "id": 32,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot에서 특정 환경(예: 개발 환경)에서만 Bean을 로드하도록 할 때 사용하는 애노테이션은?",
      "choices": [
        "@Condition",
        "@ConditionalOnProperty",
        "@Profile",
        "@ActiveProfile"
      ],
      "answer": "@Profile",
      "explanation": "@Profile(\"dev\")와 같이 사용하여 특정 프로파일이 활성화되었을 때만 해당 Bean 또는 설정을 로드합니다."
    },
    {
      "id": 33,
      "type": "descriptive",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "Spring Boot Actuator를 사용하는 주된 목적을 설명하고, /actuator/metrics 엔드포인트의 역할을 예시와 함께 설명하세요.",
      "answer": "Actuator는 실행 중인 Spring Boot 애플리케이션의 **운영 정보를 모니터링하고 상호작용**하기 위해 사용됩니다. `/actuator/metrics`는 JVM 메모리 사용량, CPU 사용량, HTTP 요청 수, 응답 시간 등 애플리케이션의 **다양한 성능 지표(Metrics)**를 제공하여 성능 분석 및 상태 진단에 도움을 줍니다.",
      "explanation": "Actuator는 개발자가 아닌 운영자/모니터링 시스템을 위한 정보를 제공합니다."
    },
    {
      "id": 34,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot에서 내장된 웹 서버(Embedded Server)를 커스터마이징(예: 포트 변경)할 때 주로 사용하는 설정 파일 속성은?",
      "answer": "server.port",
      "explanation": "`application.properties`나 `application.yml`에서 `server.port=9090`과 같이 설정하여 내장 서버의 포트를 변경할 수 있습니다."
    },
    {
      "id": 35,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "beginner",
      "question": "Spring Boot에서 애플리케이션 실행에 필요한 모든 의존성을 그룹화하여 한 번에 추가하는 데 사용되는 의존성은?",
      "choices": [
        "WebStarter",
        "FatJar",
        "Starter POM",
        "Core Dependency"
      ],
      "answer": "Starter POM",
      "explanation": "예: `spring-boot-starter-web`은 웹 개발에 필요한 모든 의존성을 포함합니다."
    },
    {
      "id": 36,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Spring MVC에서 HTTP 요청 본문(Body)의 JSON/XML 데이터를 Java 객체로 바인딩하는 데 사용되는 애노테이션은?",
      "answer": "@RequestBody",
      "explanation": "@RequestBody는 HttpMessageConverter를 사용하여 요청 본문을 객체로 변환합니다."
    },
    {
      "id": 37,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "Spring MVC에서 Controller의 예외 처리를 전역적으로 담당하는 데 사용되는 애노테이션은?",
      "choices": [
        "@ControllerAdvice",
        "@ExceptionHandler",
        "@GlobalExceptionHandler",
        "@ErrorController"
      ],
      "answer": "@ControllerAdvice",
      "explanation": "@ControllerAdvice는 모든 컨트롤러에서 발생하는 예외를 한 곳에서 처리할 수 있도록 해줍니다. 보통 이 클래스 내부에 @ExceptionHandler를 사용하여 특정 예외를 처리합니다."
    },
    {
      "id": 38,
      "type": "descriptive",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "Spring MVC의 핵심 디자인 패턴인 **MVC**에서 각 역할(Model, View, Controller)을 설명하세요.",
      "answer": "1) **Controller**: 클라이언트의 요청을 받아 비즈니스 로직을 호출하고, 그 결과를 Model에 담아 View에게 전달합니다.\n2) **Model**: 데이터와 비즈니스 로직을 포함합니다. Controller가 처리한 결과를 담는 데이터 저장소 역할도 합니다.\n3) **View**: Model의 데이터를 기반으로 사용자에게 보여줄 화면(HTML, JSON 등)을 생성합니다.",
      "explanation": "MVC 패턴은 관심사 분리를 통해 코드의 유지보수성을 높입니다."
    },
    {
      "id": 39,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Spring MVC에서 **데이터 바인딩(Data Binding)** 시 유효성 검증을 위해 사용되는 애노테이션은?",
      "answer": "@Valid (또는 @Validated)",
      "explanation": "@Valid는 JSR-303 Bean Validation 명세를 트리거하여 객체의 필드 제약 조건을 검사합니다."
    },
    {
      "id": 40,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "Spring MVC에서 **Content Negotiation**을 통해 클라이언트가 JSON 응답을 받고자 할 때 사용하는 HTTP 헤더는?",
      "choices": [
        "Content-Type",
        "Content-Disposition",
        "Accept",
        "Authorization"
      ],
      "answer": "Accept",
      "explanation": "Accept 헤더는 클라이언트가 수용 가능한 미디어 타입(예: application/json)을 서버에 알려줍니다. 서버는 이를 보고 적절한 응답 타입을 선택합니다."
    },
    {
      "id": 41,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "JPA에서 엔티티의 변경사항이 데이터베이스에 반영되는 시점을 제어하는 메서드는?",
      "answer": "EntityManager.flush()",
      "explanation": "flush()는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화(쓰기 지연 SQL 저장소의 쿼리를 실행)하지만, 트랜잭션을 커밋하지는 않습니다."
    },
    {
      "id": 42,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "beginner",
      "question": "JPA에서 지연 로딩(Lazy Loading)의 반대 개념으로, 연관된 엔티티를 즉시 로드하는 방식은?",
      "choices": [
        "Eager Loading",
        "Immediate Loading",
        "Fetch Join",
        "Direct Loading"
      ],
      "answer": "Eager Loading",
      "explanation": "@ManyToOne, @OneToOne 관계의 기본 설정이며, 연관 엔티티를 주 엔티티 조회 시 함께 로드합니다."
    },
    {
      "id": 43,
      "type": "descriptive",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "JPA에서 **영속성 전이(Cascade)**와 **고아 객체 제거(orphanRemoval)**의 차이점을 설명하세요.",
      "answer": "1) **영속성 전이(Cascade)**: 부모 엔티티에 대한 작업(PERSIST, REMOVE 등)을 자식 엔티티에게도 전파하는 기능입니다. 예: 부모 저장 시 자식도 저장됩니다.\n2) **고아 객체 제거(orphanRemoval)**: 부모 엔티티의 컬렉션에서 자식 엔티티의 참조가 끊어졌을 때(null이 아닌 컬렉션에서 제거 시), 해당 자식 엔티티를 자동으로 데이터베이스에서 삭제하는 기능입니다.",
      "explanation": "고아 객체 제거는 CascadeType.REMOVE보다 더 명확하게 자식의 생명주기를 부모에 종속시킵니다."
    },
    {
      "id": 44,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "Spring Data JPA에서 사용자 정의 쿼리를 작성할 때 사용하는 애노테이션은?",
      "answer": "@Query",
      "explanation": "@Query를 사용하여 JPQL 또는 Native SQL을 직접 정의하여 복잡한 쿼리를 실행할 수 있습니다."
    },
    {
      "id": 45,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "beginner",
      "question": "다음 중 JPA의 영속성 컨텍스트(Persistence Context)의 역할이 **아닌** 것은?",
      "choices": [
        "1차 캐시 (First-level cache)",
        "동일성 보장 (Identity)",
        "트랜잭션 쓰기 지연 (Transactional write-behind)",
        "트랜잭션 커밋 (Transaction commit)"
      ],
      "answer": "트랜잭션 커밋 (Transaction commit)",
      "explanation": "트랜잭션 커밋은 트랜잭션 매니저가 담당하며, 영속성 컨텍스트의 역할은 아닙니다. 커밋 시점에 flush가 발생합니다."
    },
    {
      "id": 46,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 사용자 인증 시 비밀번호를 안전하게 저장하기 위해 사용하는 인터페이스는?",
      "answer": "PasswordEncoder",
      "explanation": "PasswordEncoder는 BCrypt, PBKDF2 등 단방향 해시를 사용하여 비밀번호를 암호화하고 검증합니다. 기본 구현체는 DelegatingPasswordEncoder입니다."
    },
    {
      "id": 47,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "Spring Security의 필터 체인에서 `UsernamePasswordAuthenticationFilter`가 처리하는 기본 URL은?",
      "choices": [
        "/auth",
        "/login",
        "/authenticate",
        "/secure"
      ],
      "answer": "/login",
      "explanation": "이 필터는 폼 기반 로그인 요청(기본적으로 POST /login)을 가로채서 인증을 시도합니다."
    },
    {
      "id": 48,
      "type": "descriptive",
      "category": "Spring Security",
      "difficulty": "beginner",
      "question": "Spring Security에서 인증(Authentication)과 인가(Authorization)의 차이점을 간단히 설명하세요.",
      "answer": "1) **인증(Authentication)**: '이 사용자가 누구인지'를 확인하는 과정입니다. (예: 로그인 시 ID/PW 확인)\n2) **인가(Authorization)**: '인증된 이 사용자가 요청한 자원에 접근할 권한이 있는지'를 확인하는 과정입니다. (예: 관리자만 접근 가능한 페이지 허용)",
      "explanation": "인증이 먼저 성공해야 인가 과정으로 넘어갈 수 있습니다."
    },
    {
      "id": 49,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "메서드 실행 **전**에 권한을 체크할 때 사용하는 Spring Security의 애노테이션은?",
      "answer": "@PreAuthorize",
      "explanation": "@PreAuthorize는 SpEL(Spring Expression Language)을 사용하여 복잡하고 동적인 권한 체크 로직을 구현할 수 있습니다."
    },
    {
      "id": 50,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "beginner",
      "question": "Spring Security의 기본 동작으로 인해, 로그아웃 후 리다이렉트되는 기본 URL은?",
      "choices": [
        "/logout",
        "/",
        "/login?logout",
        "/home"
      ],
      "answer": "/login?logout",
      "explanation": "기본적으로는 `/login?logout`으로 리다이렉트되어 로그아웃 메시지를 표시할 수 있게 합니다."
    },
    {
      "id": 51,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "POJO(Plain Old Java Object)의 정의를 간단히 설명하세요.",
      "answer": "특정 환경이나 기술에 종속되지 않은, 순수한 Java 언어로 구현된 일반적인 Java 객체를 의미합니다.",
      "explanation": "Spring은 POJO 기반 프로그래밍을 지향하여 낮은 결합도를 유지합니다."
    },
    {
      "id": 52,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "AOP에서 **Around Advice**가 제공하는 가장 큰 이점은?",
      "choices": [
        "예외 발생 시에만 실행",
        "메서드 실행 전후 제어 및 타겟 메서드 직접 호출 여부 결정",
        "메서드 정상 완료 후에만 실행",
        "AspectJ 문법만 사용 가능"
      ],
      "answer": "메서드 실행 전후 제어 및 타겟 메서드 직접 호출 여부 결정",
      "explanation": "Around Advice는 `ProceedingJoinPoint.proceed()`를 통해 타겟 메서드의 실행 자체를 제어할 수 있는 가장 강력한 Advice입니다."
    },
    {
      "id": 53,
      "type": "descriptive",
      "category": "Spring Core",
      "difficulty": "advanced",
      "question": "Spring에서 **FactoryBean**을 사용하는 주된 이유와 일반 Bean과의 차이점을 설명하세요.",
      "answer": "FactoryBean은 복잡한 초기화 로직이나 동적 프록시 생성 등 **Bean 생성 과정을 커스터마이징**해야 할 때 사용됩니다. 일반 Bean은 자신이 객체 그 자체이지만, FactoryBean은 `getObject()` 메서드를 통해 **다른 객체(실제 Bean)**를 생성하여 반환하는 '팩토리' 역할을 합니다.",
      "explanation": "예: MyBatis의 SqlSessionFactoryBean, JndiObjectFactoryBean 등이 있습니다."
    },
    {
      "id": 54,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "Spring에서 **데이터 액세스 계층(DAO/Repository)**에 사용하는 스테레오타입 애노테이션은?",
      "answer": "@Repository",
      "explanation": "@Repository는 데이터 액세스 계층에서 발생하는 영속성 관련 예외를 Spring의 DataAccessException으로 변환하는 기능을 제공합니다."
    },
    {
      "id": 55,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "다음 중 Spring에서 트랜잭션 관리에 사용되는 주요 애노테이션은?",
      "choices": [
        "@Transaction",
        "@Transact",
        "@Transactional",
        "@DataSource"
      ],
      "answer": "@Transactional",
      "explanation": "@Transactional은 메서드 또는 클래스 레벨에서 선언적 트랜잭션을 적용하는 데 사용됩니다."
    },
    {
      "id": 56,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "Spring Boot의 자동 설정에서 특정 Bean이 클래스패스에 존재할 때만 설정을 적용하도록 하는 `@Conditional` 기반 애노테이션은?",
      "answer": "@ConditionalOnClass",
      "explanation": "@ConditionalOnClass는 JDBC 드라이버가 있을 때만 DataSource를 자동 설정하는 등 자동 설정의 핵심 메커니즘으로 사용됩니다."
    },
    {
      "id": 57,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot에서 개발 생산성을 높이기 위해 코드 변경 시 자동 재시작 등의 기능을 제공하는 모듈은?",
      "choices": [
        "Spring Boot Starter",
        "Spring Boot Actuator",
        "Spring Boot DevTools",
        "Spring Boot CLI"
      ],
      "answer": "Spring Boot DevTools",
      "explanation": "DevTools는 자동 재시작, LiveReload 등 개발 환경에 유용한 기능을 제공합니다."
    },
    {
      "id": 58,
      "type": "descriptive",
      "category": "Spring Boot",
      "difficulty": "beginner",
      "question": "Spring Boot가 전통적인 Spring 애플리케이션에 비해 가지는 주요 장점 3가지를 설명하세요.",
      "answer": "1) **간편한 설정**: 자동 설정(Auto Configuration)으로 복잡한 XML 또는 Java Config를 줄여줍니다.\n2) **내장 서버**: Tomcat, Jetty 등의 내장 서버를 사용하여 독립적으로 실행 가능한 JAR 파일을 생성할 수 있습니다.\n3) **Starter 의존성**: 의존성 관리를 단순화하고 버전 충돌을 줄여줍니다.",
      "explanation": "Spring Boot는 '관습 위의 설정(Convention over Configuration)'을 지향하여 개발을 가속화합니다."
    },
    {
      "id": 59,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot 애플리케이션이 실행될 때 기본적으로 로드되는 설정 파일의 이름은?",
      "answer": "application",
      "explanation": "`application.properties` 또는 `application.yml`입니다. 프로파일 설정 시 `application-{profile}.properties` 형태로 사용합니다."
    },
    {
      "id": 60,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "Spring Boot에서 애플리케이션 기동 시 Bean 로딩 순서와 의존성을 분석하는 데 사용되는 도구는?",
      "choices": [
        "Spring Initializr",
        "Spring Boot Admin",
        "Startup Actuator Endpoint",
        "Spring Tool Suite"
      ],
      "answer": "Startup Actuator Endpoint",
      "explanation": "Spring Boot 2.3부터 `startup` 엔드포인트를 통해 애플리케이션 시작 시 Bean 초기화 및 자동 구성 결정 과정을 확인할 수 있습니다."
    },
    {
      "id": 61,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "HTTP 메서드 중 **멱등성(Idempotent)**을 가지는 것은 무엇입니까? (GET, POST, PUT 중)",
      "answer": "GET, PUT",
      "explanation": "멱등성은 한 번 호출하든 여러 번 호출하든 결과가 동일함을 의미합니다. GET은 조회, PUT은 리소스 전체 교체이므로 멱등성을 가집니다. POST는 리소스 생성이므로 매번 다른 결과를 만듭니다."
    },
    {
      "id": 62,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Spring MVC에서 `ModelAndView` 객체의 역할은?",
      "choices": [
        "HTTP 요청 헤더 저장",
        "비즈니스 로직 수행",
        "Controller가 View에 전달할 데이터(Model)와 View 이름 지정",
        "데이터베이스 트랜잭션 관리"
      ],
      "answer": "Controller가 View에 전달할 데이터(Model)와 View 이름 지정",
      "explanation": "ModelAndView는 Model과 View 정보를 함께 담아 DispatcherServlet에게 반환하는 객체입니다."
    },
    {
      "id": 63,
      "type": "descriptive",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "Spring MVC에서 **Filter(필터)**와 **Interceptor(인터셉터)**의 차이점을 동작 시점과 사용 목적으로 구분하여 설명하세요.",
      "answer": "1) **Filter**: **Servlet 컨테이너 레벨**에서 동작하며, DispatcherServlet **이전/이후**에 실행됩니다. 인코딩, 보안(XSS), 로깅 등 **모든 HTTP 요청**에 대한 전역적인 처리에 사용됩니다.\n2) **Interceptor**: **Spring 컨텍스트 레벨**에서 동작하며, Controller 실행 **전후**에 실행됩니다. 인증/인가, 공통 모델 데이터 추가 등 **Spring Bean**과 관련된 세부적인 처리에 사용됩니다.",
      "explanation": "Filter는 스프링의 관여 없이 동작하고, Interceptor는 스프링의 주요 객체에 접근할 수 있습니다."
    },
    {
      "id": 64,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Spring MVC에서 폼 데이터나 쿼리 파라미터를 객체로 변환하여 Model에 추가하는 애노테이션은?",
      "answer": "@ModelAttribute",
      "explanation": "@ModelAttribute는 요청 파라미터를 객체에 바인딩하고, 이 객체를 Model에 자동으로 추가합니다."
    },
    {
      "id": 65,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "Spring MVC에서 `@RequestMapping` 애노테이션을 대신하여 HTTP POST 메서드에 특화된 애노테이션은?",
      "choices": [
        "@GetMapping",
        "@PutMapping",
        "@PostMapping",
        "@DeleteMapping"
      ],
      "answer": "@PostMapping",
      "explanation": "Spring 4.3부터 HTTP 메서드에 따라 `@GetMapping`, `@PostMapping` 등을 사용할 수 있게 되었습니다."
    },
    {
      "id": 66,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "beginner",
      "question": "JPA에서 테이블의 기본 키(Primary Key) 필드에 반드시 붙여야 하는 애노테이션은?",
      "answer": "@Id",
      "explanation": "@Id는 엔티티의 식별자 필드를 지정하는 데 필수입니다."
    },
    {
      "id": 67,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "JPA에서 트랜잭션이 커밋되지 않았는데 엔티티의 변경사항이 데이터베이스에 반영되는 현상(INSERT, UPDATE 쿼리 실행)을 무엇이라고 부릅니까?",
      "choices": [
        "Dirty Checking",
        "Write-Behind",
        "Flush",
        "Persistence"
      ],
      "answer": "Flush",
      "explanation": "Flush는 영속성 컨텍스트의 변경사항을 DB에 동기화하는 과정이며, 트랜잭션 커밋 직전이나 JPQL 쿼리 실행 직전에 발생합니다."
    },
    {
      "id": 68,
      "type": "descriptive",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "JPA에서 **Optimistic Lock(낙관적 락)**과 **Pessimistic Lock(비관적 락)**의 차이점을 설명하세요.",
      "answer": "1) **Optimistic Lock**: 엔티티에 **@Version** 필드를 두어 데이터가 조회 후 변경되었는지 확인합니다. 충돌 시 **재시도**하며, Lock을 걸지 않아 동시성이 높지만 충돌 빈도가 낮을 때 적합합니다.\n2) **Pessimistic Lock**: 데이터베이스의 Lock 메커니즘(`SELECT FOR UPDATE`)을 사용하여 데이터 조회 시 **즉시 Lock**을 겁니다. Lock 대기로 인해 동시성은 낮지만, 충돌 빈도가 높을 때 적합합니다.",
      "explanation": "Optimistic Lock은 트랜잭션의 충돌을 '나중에' 감지하고, Pessimistic Lock은 충돌을 '미리' 방지합니다."
    },
    {
      "id": 69,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "Spring Data JPA에서 `save()` 메서드의 동작(INSERT 또는 UPDATE)이 결정되는 기준은?",
      "answer": "엔티티의 **식별자(Primary Key)** 값의 유무입니다.",
      "explanation": "식별자 값이 `null`이거나 `@GeneratedValue`에 의해 새로 생성될 경우 INSERT, 이미 존재할 경우 UPDATE를 수행합니다."
    },
    {
      "id": 70,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "beginner",
      "question": "Spring에서 트랜잭션의 기본 전파(Propagation) 속성은?",
      "choices": [
        "REQUIRES_NEW",
        "NESTED",
        "SUPPORTS",
        "REQUIRED"
      ],
      "answer": "REQUIRED",
      "explanation": "REQUIRED는 이미 진행 중인 트랜잭션이 있으면 참여하고, 없으면 새로 시작하는 가장 흔하게 사용되는 전파 속성입니다."
    },
    {
      "id": 71,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "OAuth 2.0에서 **Authorization Code Grant Type**이 다른 Grant Type에 비해 안전한 주된 이유는 무엇입니까?",
      "answer": "Access Token이 아닌 **Authorization Code**를 클라이언트에게 노출하고, 이 코드를 **백 채널(서버)**을 통해 안전하게 Access Token으로 교환하기 때문입니다.",
      "explanation": "프런트 채널(브라우저)에 토큰이 노출될 위험이 적어 가장 권장되는 방식입니다."
    },
    {
      "id": 72,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 인증된 사용자 정보를 임시로 저장하는 `SecurityContext`의 기본 저장 전략은?",
      "choices": [
        "MODE_GLOBAL",
        "MODE_SESSION",
        "MODE_THREADLOCAL",
        "MODE_INHERITABLETHREADLOCAL"
      ],
      "answer": "MODE_THREADLOCAL",
      "explanation": "ThreadLocal을 사용하여 각 요청 스레드별로 독립적인 인증 정보를 유지합니다. 비동기 환경에서는 `MODE_INHERITABLETHREADLOCAL`을 고려해야 합니다."
    },
    {
      "id": 73,
      "type": "descriptive",
      "category": "Spring Security",
      "difficulty": "beginner",
      "question": "Spring Security의 **FilterChain**이 동작하는 방식을 간단히 설명하세요.",
      "answer": "클라이언트로부터 요청이 들어오면, 이 요청은 **여러 개의 필터**로 구성된 체인을 순차적으로 통과합니다. 각 필터는 인증, 권한 체크, CSRF 방어 등 특정 보안 작업을 수행하며, 문제가 없으면 다음 필터로 요청을 전달하고, 최종적으로 DispatcherServlet까지 도달합니다.",
      "explanation": "필터 체인은 Spring Security의 핵심 동작 원리입니다."
    },
    {
      "id": 74,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 메서드 실행 후 반환되는 값에 대한 권한을 체크할 때 사용하는 애노테이션은?",
      "answer": "@PostAuthorize",
      "explanation": "@PostAuthorize는 메서드가 실행되어 값을 반환한 후, 이 반환 값(returnObject)을 포함하여 권한을 체크할 수 있게 해줍니다."
    },
    {
      "id": 75,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "beginner",
      "question": "사용자가 로그인한 후 브라우저에 저장되어 재인증 없이 사용자를 식별하는 데 사용되는 메커니즘은?",
      "choices": [
        "Session ID",
        "JWT Token",
        "Remember-Me Cookie",
        "Principal Object"
      ],
      "answer": "Remember-Me Cookie",
      "explanation": "Remember-Me 기능은 세션이 만료된 후에도 사용자를 식별할 수 있도록 하는 쿠키 기반의 인증 메커니즘입니다."
    },
    {
      "id": 76,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "Spring에서 `@Bean`과 `@Component`의 주요 차이점은 무엇입니까?",
      "answer": "`@Component`는 개발자가 직접 작성한 클래스에 붙여 **자동으로 스캔**되도록 하는 애노테이션이고, `@Bean`은 개발자가 제어할 수 없는 **외부 라이브러리 객체**나 복잡한 로직을 통해 생성된 객체를 **수동으로 Bean으로 등록**할 때 사용됩니다.",
      "explanation": "@Bean은 주로 @Configuration 클래스의 메서드에 사용됩니다."
    },
    {
      "id": 77,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "advanced",
      "question": "Spring에서 **AspectJ**를 사용하여 AOP를 구현할 때의 장점은?",
      "choices": [
        "런타임 오버헤드가 더 크다",
        "모든 메서드에 프록시 객체가 필요하다",
        "필드 접근 및 생성자 호출에도 Advice 적용 가능",
        "Spring Bean에만 적용 가능"
      ],
      "answer": "필드 접근 및 생성자 호출에도 Advice 적용 가능",
      "explanation": "AspectJ는 컴파일/로드 타임 위빙을 통해 필드 접근, 생성자 호출 등 Spring AOP(프록시 기반)가 할 수 없는 더 넓은 범위의 Joint Point에 Advice를 적용할 수 있습니다."
    },
    {
      "id": 78,
      "type": "descriptive",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "Spring의 **@Scope** 애노테이션으로 설정할 수 있는 웹 환경에서의 주요 스코프 3가지(Web Scopes)를 설명하세요.",
      "answer": "1) **request**: HTTP 요청당 하나의 객체가 생성되어 해당 요청 내에서 공유됩니다.\n2) **session**: HTTP 세션당 하나의 객체가 생성되어 해당 세션 내에서 공유됩니다.\n3) **application**: 웹 애플리케이션(ServletContext)당 하나의 객체가 생성되어 애플리케이션 전체에서 공유됩니다.",
      "explanation": "이 스코프들은 웹 환경(`WebApplicationContext`)에서만 유효하며, 일반 Core 환경에서는 사용할 수 없습니다."
    },
    {
      "id": 79,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "Spring에서 Setter 주입을 위해 사용되는 애노테이션은?",
      "answer": "@Autowired (Setter 메서드에 적용)",
      "explanation": "Spring 4.3 이후로는 생성자 주입을 가장 권장하며, 생성자가 하나일 경우 @Autowired를 생략할 수 있습니다."
    },
    {
      "id": 80,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "Spring에서 Bean의 **소멸(Destruction)** 단계에 호출되는 콜백 메서드는?",
      "choices": [
        "init-method",
        "afterPropertiesSet()",
        "destroy-method",
        "@PostDestroy"
      ],
      "answer": "destroy-method",
      "explanation": "커스텀 `destroy-method`나 `DisposableBean.destroy()`가 소멸 시점에 호출됩니다. `@PostDestroy`는 존재하지 않습니다."
    },
    {
      "id": 81,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot에서 `application.yml` 파일에서 리스트(List)를 정의하는 문법을 간단히 예시로 보여주세요.",
      "answer": "```yaml\nservers:\n  - host: dev.example.com\n  - host: prod.example.com\n```",
      "explanation": "하이픈(`-`)과 공백을 사용하여 리스트의 요소를 정의합니다."
    },
    {
      "id": 82,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "Spring Boot 애플리케이션을 빌드할 때, 모든 의존성을 포함하여 독립적으로 실행 가능한 JAR 파일을 생성하는 Maven 플러그인은?",
      "choices": [
        "maven-compiler-plugin",
        "spring-boot-maven-plugin",
        "maven-surefire-plugin",
        "exec-maven-plugin"
      ],
      "answer": "spring-boot-maven-plugin",
      "explanation": "이 플러그인이 실행 가능한 'Fat JAR'를 생성하고, 내장 서버와 Spring Boot Loader를 포함시킵니다."
    },
    {
      "id": 83,
      "type": "descriptive",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot의 **프로파일(Profiles)**을 사용하는 주된 목적과 활성화 방법 2가지를 설명하세요.",
      "answer": "프로파일은 **환경별로 다른 설정(DB 연결, 포트 등)**을 적용해야 할 때 사용됩니다. 이를 통해 개발, 테스트, 운영 환경에 맞는 Bean과 설정을 분리하여 관리할 수 있습니다.\n활성화 방법: 1) `application.properties`에서 `spring.profiles.active=dev` 설정, 2) 명령줄 인수에서 `--spring.profiles.active=dev` 설정",
      "explanation": "프로파일은 `@Profile` 애노테이션이나 별도의 설정 파일(`application-dev.yml`)을 통해 적용됩니다."
    },
    {
      "id": 84,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "beginner",
      "question": "Spring Boot의 임베디드(내장) 서버가 기본으로 사용하는 포트 번호는?",
      "answer": "8080",
      "explanation": "설정 파일에서 `server.port` 속성을 통해 변경할 수 있습니다."
    },
    {
      "id": 85,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "다음 중 Spring Boot Actuator의 기능이 **아닌** 것은?",
      "choices": [
        "Health 체크",
        "환경 설정 정보 조회",
        "로컬 환경에서 코드 변경 시 자동 재시작",
        "스레드 덤프"
      ],
      "answer": "로컬 환경에서 코드 변경 시 자동 재시작",
      "explanation": "자동 재시작은 Spring Boot **DevTools**의 기능입니다. Actuator는 모니터링 및 운영 관련 엔드포인트를 제공합니다."
    },
    {
      "id": 86,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "Spring MVC에서 비동기 요청 처리를 위해 사용되는 두 가지 주요 반환 타입은 무엇입니까?",
      "answer": "DeferredResult와 Callable",
      "explanation": "이들은 서블릿 3.0+의 비동기 기능을 활용하여 요청 스레드를 블로킹하지 않고 작업을 처리할 수 있게 합니다."
    },
    {
      "id": 87,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "RESTful API에서 리소스 전체 수정에 적합하며, 멱등성을 보장하는 HTTP 메서드는?",
      "choices": [
        "POST",
        "PATCH",
        "PUT",
        "DELETE"
      ],
      "answer": "PUT",
      "explanation": "PUT은 리소스를 완전히 교체(수정)하는 데 사용되며, 여러 번 호출해도 최종 결과가 동일하므로 멱등성을 가집니다."
    },
    {
      "id": 88,
      "type": "descriptive",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "Spring MVC에서 정적 리소스(CSS, JS, Image)를 처리하는 기본 경로 2가지 이상을 설명하세요.",
      "answer": "Spring Boot의 기본 정적 리소스 경로는 `/static`, `/public`, `/resources`, `/META-INF/resources` 입니다. 이 경로들에 위치한 파일들은 매핑 없이 바로 접근이 가능합니다.",
      "explanation": "Spring Boot는 `ResourceHttpRequestHandler`를 통해 이 경로들을 자동으로 처리합니다."
    },
    {
      "id": 89,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Spring MVC에서 클라이언트의 쿠키 값을 읽어오는 데 사용되는 애노테이션은?",
      "answer": "@CookieValue",
      "explanation": "@CookieValue는 HTTP 요청 헤더의 Cookie 값을 메서드 파라미터로 바인딩합니다."
    },
    {
      "id": 90,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "Spring MVC의 요청 처리 흐름에서, View 이름을 실제 View 객체로 변환하는 컴포넌트는?",
      "choices": [
        "HandlerMapping",
        "HandlerAdapter",
        "ViewResolver",
        "LocaleResolver"
      ],
      "answer": "ViewResolver",
      "explanation": "Controller가 반환한 논리적 View 이름을 물리적 View(JSP, Thymeleaf 템플릿 등)로 매핑하는 역할을 합니다."
    },
    {
      "id": 91,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "JPA에서 엔티티의 변경 감지(Dirty Checking)가 동작하는 시점을 설명하세요.",
      "answer": "트랜잭션이 **커밋되거나(Commit) flush()가 호출될 때** 영속성 컨텍스트 내의 스냅샷과 현재 엔티티 상태를 비교하여 변경된 필드를 감지하고 UPDATE 쿼리를 생성합니다.",
      "explanation": "Dirty Checking 덕분에 개발자는 명시적으로 `update()`를 호출하지 않아도 됩니다."
    },
    {
      "id": 92,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "다음 중 JPA에서 **지연 로딩(Lazy Loading)**의 대상이 되는 연관 관계는?",
      "choices": [
        "@ManyToOne (기본)",
        "@OneToOne (기본)",
        "@OneToMany (기본)",
        "@Embedded"
      ],
      "answer": "@OneToMany (기본)",
      "explanation": "컬렉션 타입인 @OneToMany, @ManyToMany는 기본적으로 Lazy 로딩입니다. @ManyToOne, @OneToOne은 기본적으로 Eager 로딩입니다."
    },
    {
      "id": 93,
      "type": "descriptive",
      "category": "Spring Data JPA",
      "difficulty": "beginner",
      "question": "JPA에서 **객체 지향 쿼리 언어(Object-Oriented Query Language)**는 무엇이며, SQL과의 차이점을 설명하세요.",
      "answer": "객체 지향 쿼리 언어는 **JPQL(Java Persistence Query Language)**입니다. SQL이 **테이블**을 대상으로 쿼리하는 반면, JPQL은 **엔티티 객체**와 **필드**를 대상으로 쿼리합니다. 데이터베이스에 종속되지 않는다는 장점이 있습니다.",
      "explanation": "JPQL은 SQL과 문법이 유사하지만, FROM 절에 엔티티 이름을 사용합니다."
    },
    {
      "id": 94,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "Spring Data JPA에서 트랜잭션을 읽기 전용으로 설정하는 가장 간단한 방법은?",
      "answer": "`@Transactional(readOnly = true)`를 메서드나 클래스에 선언합니다.",
      "explanation": "읽기 전용 트랜잭션은 flush를 생략하고 리소스를 절약하여 성능을 최적화하는 데 도움을 줍니다."
    },
    {
      "id": 95,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "JPA에서 `EntityManager.find()`와 `EntityManager.getReference()`의 차이점은?",
      "choices": [
        "`find()`는 즉시 로딩, `getReference()`는 지연 로딩",
        "둘 다 즉시 로딩을 사용한다",
        "`find()`는 지연 로딩, `getReference()`는 즉시 로딩",
        "`getReference()`는 항상 예외를 반환한다"
      ],
      "answer": "`find()`는 즉시 로딩, `getReference()`는 지연 로딩",
      "explanation": "`find()`는 DB에서 실제 엔티티를 조회하고, `getReference()`는 프록시 객체(가짜 객체)를 반환하여 실제 사용 시점에 DB에 접근합니다."
    },
    {
      "id": 96,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "beginner",
      "question": "Spring Security에서 사용자 정의 로그인 로직을 처리하는 데 사용되는 주요 인터페이스는?",
      "answer": "UserDetailsService",
      "explanation": "UserDetailsService는 사용자 이름(username)을 받아 UserDetails 객체를 로드하는 역할을 합니다."
    },
    {
      "id": 97,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 인증 실패 시 처리 로직을 정의하는 데 사용되는 인터페이스는?",
      "choices": [
        "AccessDeniedHandler",
        "AuthenticationSuccessHandler",
        "AuthenticationFailureHandler",
        "LogoutHandler"
      ],
      "answer": "AuthenticationFailureHandler",
      "explanation": "AuthenticationFailureHandler는 인증 실패 시 호출되어 에러 메시지 반환, 로그 기록 등의 작업을 수행할 수 있습니다."
    },
    {
      "id": 98,
      "type": "descriptive",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "Spring Security에서 **`http.csrf().disable()`**을 호출하는 것이 권장되는 환경과 그 이유를 설명하세요.",
      "answer": "CSRF 방어는 세션 기반 인증 환경에서 필수적이지만, **RESTful API 서버**이면서 **JWT/OAuth2 등의 토큰 기반 인증**을 사용하는 **Stateless(무상태) 환경**에서는 CSRF 공격의 위험이 없어 비활성화하는 것이 일반적입니다. JWT는 요청마다 토큰을 포함하므로 CSRF 토큰의 역할이 필요 없습니다.",
      "explanation": "세션 쿠키를 사용하지 않으면 CSRF 공격 경로가 차단됩니다."
    },
    {
      "id": 99,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 권한이 없는 자원에 접근 시 발생하는 예외를 처리하는 데 사용되는 핸들러 인터페이스는?",
      "answer": "AccessDeniedHandler",
      "explanation": "인증은 되었으나 권한이 부족할 때 호출되어 403 Forbidden 응답 등을 처리합니다."
    },
    {
      "id": 100,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "beginner",
      "question": "Spring Security에서 모든 요청에 대한 접근을 거부하는 데 사용되는 권한 표현식은?",
      "choices": [
        "permitAll()",
        "denyAll()",
        "isAuthenticated()",
        "hasRole('NONE')"
      ],
      "answer": "denyAll()",
      "explanation": "`denyAll()`은 접근 통제 규칙으로, 해당 요청에 대한 모든 접근을 무조건 거부합니다. `permitAll()`은 모두 허용합니다."
    },
    {
      "id": 101,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "Spring 설정 클래스임을 명시하는 애노테이션은 무엇입니까?",
      "answer": "@Configuration",
      "explanation": "@Configuration 애노테이션은 해당 클래스가 Bean 정의를 포함하는 Spring 설정 클래스임을 나타냅니다."
    },
    {
      "id": 102,
      "type": "descriptive",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "Spring Bean의 생성 전후에 로직을 추가할 수 있게 해주는 **`BeanPostProcessor`** 인터페이스의 역할을 설명하세요.",
      "answer": "`BeanPostProcessor`는 Spring IoC 컨테이너가 Bean을 초기화하는 과정(초기화 콜백 전후)에 개입하여 커스텀 로직을 실행할 수 있게 해주는 인터페이스입니다. AOP 프록시 생성, 속성 설정 등 다양한 용도로 사용됩니다.",
      "explanation": "모든 Bean의 초기화 과정에 관여할 수 있는 강력한 확장 포인트입니다."
    },
    {
      "id": 103,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "Bean의 의존성을 **필요할 때(실제 사용 시점)**에 주입받도록 지연시키는 애노테이션은 무엇입니까?",
      "answer": "@Lazy",
      "explanation": "@Lazy는 주로 순환 참조 문제를 해결하거나, 초기 로딩 속도를 향상시키기 위해 사용됩니다."
    },
    {
      "id": 104,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "다음 중 **웹 환경(Web ApplicationContext)**에서만 유효한 Bean 스코프가 **아닌** 것은?",
      "choices": [
        "request",
        "session",
        "prototype",
        "application"
      ],
      "answer": "prototype",
      "explanation": "request, session, application 스코프는 웹 환경에서만 동작합니다. prototype은 웹 환경이 아니어도 사용할 수 있는 핵심 스코프입니다."
    },
    {
      "id": 105,
      "type": "descriptive",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "Spring의 **이벤트(Event)** 처리 방식을 **`ApplicationEvent`**와 **`@EventListener`**를 사용하여 설명하세요.",
      "answer": "개발자가 `ApplicationEvent`를 상속받아 커스텀 이벤트를 정의하고, `ApplicationEventPublisher`를 통해 이벤트를 발행(publish)합니다. `@EventListener` 애노테이션이 붙은 메서드는 해당 타입의 이벤트를 수신(subscribe)하여 처리합니다.",
      "explanation": "Spring의 이벤트 메커니즘은 모듈 간의 결합도를 낮추는 데 유용합니다."
    },
    {
      "id": 106,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "advanced",
      "question": "자신이 속한 **`ApplicationContext`**를 주입받기 위해 구현해야 하는 `Aware` 인터페이스는 무엇입니까?",
      "answer": "ApplicationContextAware",
      "explanation": "`ApplicationContextAware`를 구현하면 Spring 컨테이너 자체에 접근하여 다른 Bean을 동적으로 조회하는 등의 작업을 할 수 있습니다."
    },
    {
      "id": 107,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "다음 중 Spring AOP의 **Advice** 타입이 **아닌** 것은?",
      "choices": [
        "Around",
        "Before",
        "AfterReturning",
        "OnException"
      ],
      "answer": "OnException",
      "explanation": "Spring AOP의 5가지 Advice 타입은 Before, AfterReturning, AfterThrowing, After(Finally), Around입니다. `OnException`은 `AfterThrowing`에 해당합니다."
    },
    {
      "id": 108,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "Spring 설정 클래스에서 외부 프로퍼티 파일(예: `app.properties`)을 로드하기 위해 사용하는 애노테이션은?",
      "answer": "@PropertySource",
      "explanation": "`@PropertySource(\"classpath:app.properties\")`와 같이 사용하여 Environment에 속성을 로드합니다."
    },
    {
      "id": 109,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "advanced",
      "question": "Spring AOP의 **Pointcut 표현식** 중 `com.example.service` 패키지 내의 모든 메서드를 대상으로 하는 표현식은?",
      "choices": [
        "execution(* com.example.service.*(..))",
        "execution(* com.example.service..*.*(..))",
        "within(com.example.service.*)",
        "within(com.example.service..*)"
      ],
      "answer": "within(com.example.service..*)",
      "explanation": "`execution(* com.example.service..*.*(..))`도 맞지만, `within`은 타입(클래스) 기준으로 매칭합니다. `..*`는 해당 패키지 및 모든 하위 패키지를 의미합니다."
    },
    {
      "id": 110,
      "type": "descriptive",
      "category": "Spring Core",
      "difficulty": "advanced",
      "question": "AOP 포인트컷 표현식에서 **`target()`**과 **`this()`**의 차이점을 설명하세요.",
      "answer": "**`target()`**은 **프록시가 감싸고 있는 실제 대상 객체(Target Object)**의 타입을 기준으로 매칭합니다. **`this()`**는 **생성된 프록시 객체(Proxy Object)** 자체의 타입을 기준으로 매칭합니다.",
      "explanation": "CGLIB 프록시의 경우 `this`와 `target`이 다를 수 있으며, 주로 `target`을 사용하는 것이 일반적입니다."
    },
    {
      "id": 111,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "beginner",
      "question": "**`spring-boot-starter-test`** 의존성이 기본적으로 포함하는 핵심 라이브러리 3가지는 무엇입니까?",
      "answer": "JUnit (JUnit 5), Mockito, Spring Test (및 Spring Boot Test)",
      "explanation": "이 스타터는 Spring Boot 애플리케이션을 테스트하는 데 필요한 대부분의 도구를 제공합니다."
    },
    {
      "id": 112,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot 통합 테스트에서 전체 Spring 컨텍스트를 로드하는 데 사용되는 핵심 애노테이션은?",
      "choices": [
        "@Test",
        "@SpringBootTest",
        "@WebMvcTest",
        "@DataJpaTest"
      ],
      "answer": "@SpringBootTest",
      "explanation": "@SpringBootTest는 실제 운영 환경과 가장 유사한 통합 테스트 환경을 제공합니다."
    },
    {
      "id": 113,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot에서 내장 웹 서버를 기본 **Tomcat**에서 **Undertow**로 변경하려면 어떻게 해야 합니까?",
      "answer": "`build.gradle` 또는 `pom.xml`에서 `spring-boot-starter-web`의 Tomcat 의존성을 제외(exclude)하고, `spring-boot-starter-undertow` 의존성을 추가합니다.",
      "explanation": "Spring Boot는 클래스패스에 있는 서버 구현체를 자동으로 감지하여 사용합니다."
    },
    {
      "id": 114,
      "type": "descriptive",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "Spring Boot의 **`FailureAnalyzer`**는 어떤 역할을 하며, 언제 사용됩니까?",
      "answer": "`FailureAnalyzer`는 애플리케이션 시작(startup) 시 발생하는 **예외를 감지**하고, 해당 예외의 원인을 **분석**하여 개발자에게 **친절하고 명확한 실패 리포트**를 제공하는 역할을 합니다.",
      "explanation": "예: 'Port 8080 is already in use'와 같은 명확한 에러 메시지를 생성합니다."
    },
    {
      "id": 115,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot의 자동 설정에서, 특정 Bean이 이미 컨텍스트에 등록되어 있지 **않을 때만** Bean을 등록하도록 하는 애노테이션은?",
      "choices": [
        "@ConditionalOnBean",
        "@ConditionalOnMissingBean",
        "@ConditionalOnClass",
        "@ConditionalOnProperty"
      ],
      "answer": "@ConditionalOnMissingBean",
      "explanation": "개발자가 직접 정의한 Bean이 자동 설정 Bean을 오버라이드할 수 있도록 허용하는 중요한 조건부 애노테이션입니다."
    },
    {
      "id": 116,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "beginner",
      "question": "Spring Boot 애플리케이션의 시작점인 `main` 메서드에서 호출되는 핵심 정적 메서드는 무엇입니까?",
      "answer": "SpringApplication.run()",
      "explanation": "이 메서드 호출 하나로 자동 설정, 내장 서버 실행, 컴포넌트 스캔 등 모든 부트스트래핑 과정이 실행됩니다."
    },
    {
      "id": 117,
      "type": "descriptive",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "**Spring Boot Admin**을 사용하는 주된 목적을 설명하세요.",
      "answer": "Spring Boot Admin은 실행 중인 여러 Spring Boot 애플리케이션(Actuator 엔드포인트를 노출하는)을 **중앙에서 모니터링하고 관리**하기 위한 UI 대시보드입니다.",
      "explanation": "Health 상태, Metrics, JVM 정보 등을 웹 UI를 통해 쉽게 확인할 수 있습니다."
    },
    {
      "id": 118,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "프로퍼티를 객체로 바인딩할 때, `@Component`와 `@ConfigurationProperties`를 함께 사용하는 대신 권장되는 애노테이션은?",
      "choices": [
        "@EnableConfigurationProperties",
        "@Import(ConfigurationProperties.class)",
        "@Bean",
        "@AutoConfigureProperties"
      ],
      "answer": "@EnableConfigurationProperties",
      "explanation": "`@EnableConfigurationProperties(MyProperties.class)`를 설정 클래스에 추가하면, 해당 프로퍼티 클래스를 스캔 대상이 아니어도 Bean으로 등록하고 바인딩해줍니다."
    },
    {
      "id": 119,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot 테스트에서 **JPA 관련 계층(Repository, Entity)**만 테스트하고 싶을 때 사용하는 슬라이스 테스트 애노테이션은?",
      "answer": "@DataJpaTest",
      "explanation": "@DataJpaTest는 JPA 관련 설정과 Bean만 로드하며, 기본적으로 인메모리 데이터베이스를 사용하여 테스트를 격리합니다."
    },
    {
      "id": 120,
      "type": "descriptive",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "다른 프로젝트에서 재사용할 수 있는 **커스텀 Spring Boot Starter**를 만드는 과정을 간단히 설명하세요.",
      "answer": "1) 자동 설정을 담당하는 `xxx-spring-boot-autoconfigure` 모듈과 의존성을 정의하는 `xxx-spring-boot-starter` 모듈을 분리합니다.\n2) AutoConfigure 모듈에서 `@Configuration`과 `@Conditional...` 애노테이션을 사용하여 자동 설정 클래스를 만듭니다.\n3) `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` 파일에 자동 설정 클래스의 경로를 등록합니다.",
      "explanation": "커스텀 스타터를 통해 공통 설정과 의존성을 쉽게 공유할 수 있습니다."
    },
    {
      "id": 121,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "Controller 메서드의 반환 값이 View 이름이 아닌, **HTTP 응답 본문(Body)**에 직접 작성되어야 함을 나타내는 애노테이션은?",
      "answer": "@ResponseBody",
      "explanation": "@RestController는 모든 메서드에 이 애노테이션이 암묵적으로 적용된 것입니다."
    },
    {
      "id": 122,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Controller 메서드에서 **HTTP 상태 코드, 헤더, 응답 본문**을 모두 포함하여 반환할 때 사용하는 객체는?",
      "choices": [
        "Response",
        "HttpEntity",
        "ModelAndView",
        "ResponseEntity"
      ],
      "answer": "ResponseEntity",
      "explanation": "`ResponseEntity`는 `HttpEntity`를 상속받아 상태 코드(HttpStatus)를 추가로 다룰 수 있게 해줍니다. (예: `ResponseEntity.ok(body)`)"
    },
    {
      "id": 123,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Controller 메서드에서 HTTP 요청 **헤더(Header)**의 특정 값을 파라미터로 주입받을 때 사용하는 애노테이션은?",
      "answer": "@RequestHeader",
      "explanation": "예: `@RequestHeader(\"User-Agent\") String userAgent`와 같이 사용합니다."
    },
    {
      "id": 124,
      "type": "descriptive",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "**`HttpMessageConverter`**의 역할은 무엇이며, 가장 많이 사용되는 구현체 2가지를 드세요.",
      "answer": "`HttpMessageConverter`는 `@RequestBody`나 `@ResponseBody`가 사용될 때, HTTP 요청/응답 본문을 Java 객체로 변환하거나 그 반대로 변환하는 역할을 합니다. \n주요 구현체: 1) **`MappingJackson2HttpMessageConverter`** (JSON 처리), 2) **`StringHttpMessageConverter`** (단순 문자열 처리)",
      "explanation": "Spring Boot는 클래스패스에 Jackson 라이브러리가 있으면 MappingJackson2HttpMessageConverter를 자동으로 등록합니다."
    },
    {
      "id": 125,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Spring MVC에서 특정 Controller나 메서드에 대해 **CORS(Cross-Origin Resource Sharing)**를 허용하는 가장 간단한 애노테이션은?",
      "choices": [
        "@CrossOrigin",
        "@EnableCORS",
        "@AllowOrigin",
        "@CORSPolicy"
      ],
      "answer": "@CrossOrigin",
      "explanation": "클래스나 메서드 레벨에 `@CrossOrigin(origins = \"http://example.com\")`과 같이 사용하여 간단하게 CORS 설정을 할 수 있습니다."
    },
    {
      "id": 126,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "Spring MVC에서 **파일 업로드**를 처리할 때, 업로드된 파일 데이터를 담는 데 사용되는 객체는?",
      "answer": "MultipartFile",
      "explanation": "`MultipartFile` 인터페이스는 업로드된 파일의 이름, 크기, 바이트 데이터, 스트림 등을 제공합니다."
    },
    {
      "id": 127,
      "type": "descriptive",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Spring에서 제공하는 HTTP 클라이언트 중, **`RestTemplate`**과 **`WebClient`**의 가장 큰 차이점(동작 방식)은 무엇입니까?",
      "answer": "**`RestTemplate`**은 **동기식(Synchronous)**, 블로킹(Blocking) 방식으로 동작합니다. 반면 **`WebClient`**는 Spring WebFlux 모듈에 포함되며, **비동기식(Asynchronous)**, 논블로킹(Non-Blocking) 방식으로 동작합니다.",
      "explanation": "현재는 비동기 처리가 가능한 `WebClient`의 사용이 권장됩니다."
    },
    {
      "id": 128,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "Controller의 특정 Model 속성을 **HTTP 세션**에 임시로 저장하여 여러 요청 간에 공유하도록 하는 애노테이션은?",
      "choices": [
        "@SessionScope",
        "@SessionAttribute",
        "@SessionAttributes",
        "@SharedSession"
      ],
      "answer": "@SessionAttributes",
      "explanation": "`@SessionAttributes(\"data\")`와 같이 클래스 레벨에 선언하면, `model.addAttribute(\"data\", ...)`로 추가된 속성이 세션에도 저장됩니다."
    },
    {
      "id": 129,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "**`@GetMapping`** 애노테이션은 `@RequestMapping` 애노테이션의 어떤 속성을 결합한 축약형입니까?",
      "answer": "`@RequestMapping(method = RequestMethod.GET)`",
      "explanation": "@PostMapping, @PutMapping, @DeleteMapping 등도 동일한 방식으로 동작합니다."
    },
    {
      "id": 130,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "RESTful API에서 리소스의 **일부분만 수정**할 때 사용하는 HTTP 메서드는?",
      "choices": [
        "POST",
        "PUT",
        "PATCH",
        "UPDATE"
      ],
      "answer": "PATCH",
      "explanation": "PUT은 리소스 전체를 교체하는 반면, PATCH는 리소스의 일부 필드만 변경하는 데 사용됩니다."
    },
    {
      "id": 131,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "beginner",
      "question": "Spring Data JPA의 **`CrudRepository`**와 **`JpaRepository`**의 차이점은 무엇입니까?",
      "answer": "`JpaRepository`는 `CrudRepository`와 `PagingAndSortingRepository`를 상속받으며, **페이징/정렬 기능**과 **JPA 특화 기능**(예: `flush()`, `saveAndFlush()`)을 추가로 제공합니다.",
      "explanation": "일반적으로 `JpaRepository`가 더 많은 기능을 제공하여 자주 사용됩니다."
    },
    {
      "id": 132,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "JPA의 `@GeneratedValue` 애노테이션에서, **DB의 auto_increment** 컬럼을 사용하도록 위임하는 전략은?",
      "choices": [
        "SEQUENCE",
        "TABLE",
        "IDENTITY",
        "AUTO"
      ],
      "answer": "IDENTITY",
      "explanation": "IDENTITY 전략은 DB에 ID 생성을 위임합니다. (예: MySQL의 AUTO_INCREMENT). SEQUENCE는 DB 시퀀스 객체를 사용합니다. (예: Oracle, PostgreSQL)"
    },
    {
      "id": 133,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "JPA 엔티티의 특정 필드를 데이터베이스 테이블에 매핑하지 **않고** 순수하게 객체 필드로만 사용하고 싶을 때 붙이는 애노테이션은?",
      "answer": "@Transient",
      "explanation": "@Transient가 붙은 필드는 영속성 컨텍스트가 관리하지 않으며, 테이블 컬럼으로 생성되지 않습니다."
    },
    {
      "id": 134,
      "type": "descriptive",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "JPA에서 **복합 키(Composite Key)**를 구현하는 두 가지 방법, **`@EmbeddedId`**와 **`@IdClass`**의 차이점을 설명하세요.",
      "answer": "1) **`@EmbeddedId`**: 식별자 클래스 자체를 `@Embeddable`로 만들고, 엔티티 내에서 `@EmbeddedId`로 이 식별자 객체를 직접 필드로 가집니다. (더 객체지향적)\n2) **`@IdClass`**: 식별자 클래스를 별도로 정의한 후, 엔티티에 `@IdClass`로 지정하고 엔티티 내에는 식별자 필드들을 **개별적으로** 선언합니다.",
      "explanation": "@EmbeddedId는 식별자 객체로 조회해야 하고, @IdClass는 개별 필드 값으로 조회할 수 있습니다."
    },
    {
      "id": 135,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "JPA의 연관 관계 매핑에서 **`@ManyToOne`**의 기본 Fetch 전략(FetchType)은 무엇입니까?",
      "choices": [
        "FetchType.LAZY",
        "FetchType.EAGER",
        "FetchType.DEFAULT",
        "FetchType.AUTO"
      ],
      "answer": "FetchType.EAGER",
      "explanation": "@ManyToOne과 @OneToOne은 기본이 즉시 로딩(EAGER)이며, 컬렉션인 @OneToMany, @ManyToMany는 기본이 지연 로딩(LAZY)입니다. N+1 문제를 피하기 위해 LAZY로 설정하는 것이 좋습니다."
    },
    {
      "id": 136,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "Spring Data JPA의 `@Query` 애노테이션과 함께 사용하여 **UPDATE 또는 DELETE** 쿼리를 실행할 수 있게 하는 애노테이션은?",
      "answer": "@Modifying",
      "explanation": "@Modifying 애노테이션은 해당 쿼리가 JPQL의 상태를 변경하는 쿼리임을 나타냅니다. (예: `@Modifying @Query(\"UPDATE User u SET u.name = ?1\")`)"
    },
    {
      "id": 137,
      "type": "descriptive",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "Spring Data JPA의 **프로젝션(Projections)** 기능이 무엇이며, 왜 사용합니까?",
      "answer": "프로젝션은 엔티티의 **일부 필드만** 선택적으로 조회하여 DTO나 인터페이스로 바로 반환받는 기능입니다. 엔티티 전체를 조회하지 않고 필요한 데이터만 가져오므로 **성능 최적화**와 **네트워크 부하 감소**에 유용합니다.",
      "explanation": "인터페이스 기반 프로젝션이나 클래스 기반(DTO) 프로젝션을 사용할 수 있습니다."
    },
    {
      "id": 138,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "JPA에서 여러 엔티티가 공통으로 가지는 **매핑 정보(예: 생성일, 수정일)**를 상속받도록 하는 데 사용하는 애노테이션은?",
      "choices": [
        "@Inheritance",
        "@EntityListeners",
        "@MappedSuperclass",
        "@Embeddable"
      ],
      "answer": "@MappedSuperclass",
      "explanation": "@MappedSuperclass가 붙은 클래스는 엔티티가 아니지만, 이 클래스를 상속받는 엔티티에게 필드와 매핑 정보를 물려줍니다."
    },
    {
      "id": 139,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "beginner",
      "question": "Spring Data JPA의 **Auditing** 기능에서, 엔티티가 생성된 시간을 자동으로 기록하는 데 사용되는 애노테이션은?",
      "answer": "@CreatedDate",
      "explanation": "마지막 수정 시간을 기록하는 애노테이션은 `@LastModifiedDate`입니다. `@EnableJpaAuditing` 설정이 필요합니다."
    },
    {
      "id": 140,
      "type": "descriptive",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "JPA 설정 중 **`spring.jpa.hibernate.ddl-auto`** 속성의 주요 옵션 4가지(create, update, validate, none)를 설명하세요.",
      "answer": "1) **create**: 애플리케이션 시작 시 기존 테이블을 삭제하고 새로 생성합니다. (테스트용)\n2) **update**: 변경된 스키마만 감지하여 갱신합니다. (개발용)\n3) **validate**: 엔티티와 테이블이 일치하는지 검증합니다.\n4) **none**: 아무 작업도 하지 않습니다. (운영 환경 권장)",
      "explanation": "운영 환경에서는 `none` 또는 `validate`를 사용하고, Flyway나 Liquibase 같은 도구로 스키마를 관리하는 것이 좋습니다."
    },
    {
      "id": 141,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "beginner",
      "question": "Spring Security에서 사용자의 **권한(Role)**을 문자열로 나타내는 데 사용되는 핵심 인터페이스는?",
      "answer": "GrantedAuthority",
      "explanation": "UserDetails는 `Collection<? extends GrantedAuthority>`를 반환하며, 각 `GrantedAuthority`는 'ROLE_USER', 'ROLE_ADMIN'과 같은 권한을 나타냅니다."
    },
    {
      "id": 142,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 실제 **인증 로직**을 수행하고 `Authentication` 객체를 반환하는 핵심 컴포넌트는?",
      "choices": [
        "SecurityContextHolder",
        "AuthenticationManager",
        "AccessDecisionManager",
        "UserDetailsService"
      ],
      "answer": "AuthenticationManager",
      "explanation": "`AuthenticationManager`는 `AuthenticationProvider`에게 인증을 위임하여 실제 인증을 수행합니다."
    },
    {
      "id": 143,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "**메서드 레벨 보안**(예: `@PreAuthorize`, `@Secured`)을 활성화하기 위해 설정 클래스에 추가하는 애노테이션은?",
      "answer": "@EnableGlobalMethodSecurity (또는 @EnableMethodSecurity)",
      "explanation": "예: `@EnableGlobalMethodSecurity(prePostEnabled = true)`는 `@PreAuthorize`, `@PostAuthorize` 사용을 활성화합니다. (최신 버전에서는 `@EnableMethodSecurity`를 권장합니다.)"
    },
    {
      "id": 144,
      "type": "descriptive",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "최신 Spring Security에서 **`WebSecurityConfigurerAdapter`**를 상속하는 대신, **`SecurityFilterChain`**을 Bean으로 등록하는 방식의 장점은?",
      "answer": "`SecurityFilterChain`을 Bean으로 등록하는 방식은 Spring의 컴포넌트 기반 설정을 따르며, **여러 개의 독립적인 필터 체인**을 조건부로 구성하기 용이합니다. `WebSecurityConfigurerAdapter`는 단일 구성에 초점이 맞춰져 있고 현재는 **Deprecated** 되었습니다.",
      "explanation": "컴포넌트 기반 접근 방식은 Spring Boot의 자동 설정과 더 잘 통합됩니다."
    },
    {
      "id": 145,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "OAuth 2.0 Grant Type 중, 브라우저 기반의 **SPA(Single Page Application)**에서 가장 안전하게 사용되도록 권장되는 방식은?",
      "choices": [
        "Implicit Grant",
        "Resource Owner Password Credentials Grant",
        "Authorization Code Grant (with PKCE)",
        "Client Credentials Grant"
      ],
      "answer": "Authorization Code Grant (with PKCE)",
      "explanation": "PKCE(Proof Key for Code Exchange)는 클라이언트 시크릿을 안전하게 저장할 수 없는 SPA 환경에서 'Authorization Code' 탈취 공격을 방지합니다."
    },
    {
      "id": 146,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "Spring Security의 `AuthenticationManager`가 실제 인증을 위임하는 컴포넌트로, **인증 로직(예: DB 조회 및 암호 비교)**을 캡슐화하는 인터페이스는?",
      "answer": "AuthenticationProvider",
      "explanation": "`DaoAuthenticationProvider`는 `UserDetailsService`와 `PasswordEncoder`를 사용하여 폼 로그인을 처리하는 기본 구현체입니다."
    },
    {
      "id": 147,
      "type": "descriptive",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring의 메서드 보안 애노테이션인 **`@Secured`**와 **`@PreAuthorize`**의 차이점을 설명하세요.",
      "answer": "**`@Secured`**는 **단순한 Role 문자열**(예: `@Secured(\"ROLE_ADMIN\")`)만으로 권한을 체크합니다.\n**`@PreAuthorize`**는 **SpEL(Spring Expression Language)**을 사용하여 **복잡하고 동적인 권한 체크**(예: `@PreAuthorize(\"hasRole('ADMIN') or #username == principal.username\")`)가 가능합니다.",
      "explanation": "@PreAuthorize가 훨씬 더 유연하고 강력한 기능을 제공합니다."
    },
    {
      "id": 148,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "Spring Security에서 여러 `AccessDecisionVoter`의 투표를 집계하여 최종 접근 결정을 내리는 컴포넌트의 기본 전략은?",
      "choices": [
        "ConsensusBased (다수결)",
        "AffirmativeBased (하나라도 승인하면 허용)",
        "UnanimousBased (만장일치)",
        "PriorityBased (우선순위 기반)"
      ],
      "answer": "AffirmativeBased (하나라도 승인하면 허용)",
      "explanation": "기본적으로 하나 이상의 Voter가 접근을 승인(ACCESS_GRANTED)하면, 나머지 Voter의 기권(ABSTAIN)에 관계없이 접근이 허용됩니다."
    },
    {
      "id": 149,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 **익명 사용자(Anonymous User)**의 인증 정보를 나타내는 `Authentication` 구현체는?",
      "answer": "AnonymousAuthenticationToken",
      "explanation": "익명 사용자도 `ROLE_ANONYMOUS`라는 기본 권한을 가진 인증된 주체로 처리되어 보안 로직의 일관성을 유지합니다."
    },
    {
      "id": 150,
      "type": "descriptive",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security 설정을 통해 **CORS**를 전역적으로 구성하는 방법을 설명하세요.",
      "answer": "`SecurityFilterChain` Bean 설정 내에서 `http.cors(Customizer.withDefaults())`를 호출하여 Spring MVC에 정의된 CORS 설정을 따르도록 하거나, `http.cors().configurationSource(...)`를 통해 Security 레벨에서 직접 CORS 설정을 정의할 수 있습니다.",
      "explanation": "Spring MVC의 전역 CORS 설정(`WebMvcConfigurer`)과 Security의 CORS 설정을 일치시키는 것이 중요합니다."
    },
    {
      "id": 151,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "`@Service`와 `@Component` 애노테이션의 기능적 차이는 무엇입니까?",
      "answer": "기능적으로는 동일하게 Bean으로 등록되지만, `@Service`는 **비즈니스 로직**을 담당하는 서비스 계층임을 명시적으로 나타내는 **용도상의 구분**을 위해 사용됩니다.",
      "explanation": "가독성과 계층 구분을 위해 `@Service`, `@Repository`, `@Controller` 등을 사용하는 것이 좋습니다."
    },
    {
      "id": 152,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "`@Transactional(readOnly = true)` 설정이 가져다주는 성능상 이점이 **아닌** 것은?",
      "choices": [
        "JPA에서 Flush를 생략하여 Dirty Checking 비용 감소",
        "읽기 전용 복제(Replica) DB로 쿼리를 라우팅 (DB 드라이버 지원 시)",
        "트랜잭션 락(Lock)을 걸지 않아 동시성 향상",
        "SELECT 쿼리가 아닌 UPDATE 쿼리의 속도 향상"
      ],
      "answer": "SELECT 쿼리가 아닌 UPDATE 쿼리의 속도 향상",
      "explanation": "readOnly=true는 변경 작업을 수행하지 않음을 명시하므로 UPDATE 쿼리는 실행되어서는 안 됩니다. 주된 이점은 불필요한 변경 감지(Dirty Checking) 및 Flush를 생략하는 것입니다."
    },
    {
      "id": 153,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "**SpEL(Spring Expression Language)**을 사용하여 `@Value` 애노테이션으로 다른 Bean의 속성 값을 주입하는 예시를 보여주세요.",
      "answer": "`@Value(\"#{otherBean.propertyName}\")`",
      "explanation": "SpEL은 `#` 기호를 사용하여 표현식을 시작하며, 프로퍼티 값을 주입하는 `$`(`@Value(\"${my.property}\")`)와 구분됩니다."
    },
    {
      "id": 154,
      "type": "descriptive",
      "category": "Spring Core",
      "difficulty": "advanced",
      "question": "**`prototype`** 스코프 Bean의 생명주기가 **`singleton`** 스코프와 다른 점을 설명하세요.",
      "answer": "**`singleton`** Bean은 컨테이너가 생성, 초기화, 소멸까지 모든 생명주기를 관리합니다. 반면, **`prototype`** Bean은 컨테이너가 생성 및 초기화까지만 관여하고, 클라이언트에게 객체를 반환한 후에는 더 이상 **관리하지 않습니다**. 따라서 `@PreDestroy`와 같은 소멸 콜백이 호출되지 않습니다.",
      "explanation": "prototype Bean의 소멸은 해당 Bean을 사용한 클라이언트가 직접 관리해야 합니다."
    },
    {
      "id": 155,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "Spring 트랜잭션 전파 속성 중 **`Propagation.REQUIRES_NEW`**는 어떻게 동작합니까?",
      "choices": [
        "기존 트랜잭션에 참여한다.",
        "기존 트랜잭션과 상관없이 항상 새로운 트랜잭션을 시작한다.",
        "기존 트랜잭션이 없으면 예외를 발생시킨다.",
        "트랜잭션 없이 실행한다."
      ],
      "answer": "기존 트랜잭션과 상관없이 항상 새로운 트랜잭션을 시작한다.",
      "explanation": "항상 새로운 물리적 트랜잭션을 생성하며, 기존 트랜잭션이 있다면 그것을 잠시 보류시킵니다."
    },
    {
      "id": 156,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "advanced",
      "question": "Spring에서 **커스텀 이벤트**를 발행(publish)하기 위해 주입받는 인터페이스는 무엇입니까?",
      "answer": "ApplicationEventPublisher",
      "explanation": "`applicationEventPublisher.publishEvent(new MyCustomEvent(this, ...))`와 같이 사용하여 이벤트를 발행합니다."
    },
    {
      "id": 157,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "Spring Boot 환경에서 AOP 프록시를 생성할 때 기본적으로 사용되는 기술은?",
      "choices": [
        "JDK Dynamic Proxy",
        "CGLIB",
        "AspectJ",
        "Javassist"
      ],
      "answer": "CGLIB",
      "explanation": "Spring Boot는 기본적으로 CGLIB를 사용하여 인터페이스가 없는 클래스에도 AOP를 적용할 수 있도록 합니다. (proxy-target-class=true가 기본값)"
    },
    {
      "id": 158,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "`@Autowired`로 의존성을 주입할 때, 동일한 타입의 Bean이 여러 개 있을 경우 **우선순위**를 부여하는 애노테이션은?",
      "answer": "@Primary",
      "explanation": "`@Primary`가 붙은 Bean이 `@Qualifier`가 없는 한 우선적으로 주입됩니다."
    },
    {
      "id": 159,
      "type": "descriptive",
      "category": "Spring Core",
      "difficulty": "advanced",
      "question": "Spring의 **`MessageSource`** 인터페이스가 사용되는 주된 목적(i18n)을 설명하세요.",
      "answer": "`MessageSource`는 **국제화(i18n, Internationalization)**를 지원하기 위해 사용됩니다. 코드에 하드코딩된 메시지를 외부 파일(예: `messages_en.properties`, `messages_ko.properties`)로 분리하고, 사용자의 로케일(Locale)에 맞는 언어의 메시지를 동적으로 불러올 수 있게 합니다.",
      "explanation": "다국어 지원이 필요한 애플리케이션에 필수적입니다."
    },
    {
      "id": 160,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "Spring의 **`Environment`** 추상화 인터페이스가 제공하는 두 가지 주요 기능은?",
      "choices": [
        "프로퍼티(Properties) 접근 및 프로파일(Profiles) 관리",
        "Bean 생명주기 관리 및 이벤트 발행",
        "AOP 프록시 생성 및 트랜잭션 관리",
        "HTTP 요청 처리 및 응답 반환"
      ],
      "answer": "프로퍼티(Properties) 접근 및 프로파일(Profiles) 관리",
      "explanation": "`Environment`는 `.properties` 파일, 환경 변수, JVM 옵션 등 다양한 프로퍼티 소스에 접근하고, 활성 프로파일을 확인하는 데 사용됩니다."
    },
    {
      "id": 161,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "beginner",
      "question": "**`spring-boot-starter-web`**이 기본적으로 포함하는 내장 서블릿 컨테이너는 무엇입니까?",
      "answer": "Tomcat (spring-boot-starter-tomcat)",
      "explanation": "Spring Boot는 Tomcat, Jetty, Undertow를 내장 서버로 지원하며, 기본값은 Tomcat입니다."
    },
    {
      "id": 162,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot 테스트에서 **`@MockBean`**과 Mockito의 **`@Mock`**의 가장 큰 차이점은?",
      "choices": [
        "@MockBean은 실제 Bean을 생성하고, @Mock은 가짜 객체를 생성한다.",
        "@MockBean은 Spring의 **ApplicationContext**에 가짜 객체를 Bean으로 등록하고, @Mock은 순수 Mockito 객체를 생성한다.",
        "@MockBean은 생성자 주입만 가능하고, @Mock은 필드 주입만 가능하다.",
        "둘은 완전히 동일한 기능을 한다."
      ],
      "answer": "@MockBean은 Spring의 **ApplicationContext**에 가짜 객체를 Bean으로 등록하고, @Mock은 순수 Mockito 객체를 생성한다.",
      "explanation": "@MockBean은 `@Autowired`로 주입되는 Bean을 가짜 객체로 대체할 때 사용되며, `@Mock`은 단위 테스트에서 의존성을 수동으로 주입할 때 사용됩니다."
    },
    {
      "id": 163,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "`application.yml` 파일에서 **프로파일별 설정**을 하나의 파일에 정의할 때 사용하는 구분자는?",
      "answer": "--- (하이픈 세 개)",
      "explanation": "`---`를 사용하여 문서를 분리하고 `spring.config.activate.on-profile` (또는 `spring.profiles`) 속성으로 프로파일을 지정합니다."
    },
    {
      "id": 164,
      "type": "descriptive",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "Spring Boot의 실행 가능한 JAR(Fat JAR) 파일 내부에 포함된 **`spring-boot-loader`**의 역할은 무엇입니까?",
      "answer": "`spring-boot-loader`는 내장된 의존성 JAR(nested JAR)들을 로드할 수 있도록 **커스텀 클래스 로더**를 제공합니다. `java -jar` 명령어 실행 시, `spring-boot-loader`가 먼저 실행되어 내장된 JAR들을 클래스패스에 추가하고, 애플리케이션의 `main` 메서드를 호출합니다.",
      "explanation": "이 로더 덕분에 복잡한 클래스패스 설정 없이 단일 JAR 파일로 배포 및 실행이 가능합니다."
    },
    {
      "id": 165,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot Actuator에서 **`@ConfigurationProperties`**로 바인딩된 모든 Bean의 속성을 확인하는 엔드포인트는?",
      "choices": [
        "/actuator/beans",
        "/actuator/env",
        "/actuator/configprops",
        "/actuator/properties"
      ],
      "answer": "/actuator/configprops",
      "explanation": "/actuator/env는 모든 환경 속성을 보여주지만, /actuator/configprops는 실제 Bean에 바인딩된 속성을 구조화하여 보여줍니다."
    },
    {
      "id": 166,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "Spring Boot 애플리케이션 시작 시 콘솔에 출력되는 **ASCII 아트 배너**를 커스터마이징하는 방법은?",
      "answer": "클래스패스 루트에 `banner.txt` 파일을 생성하고, 원하는 ASCII 아트나 텍스트를 넣습니다.",
      "explanation": "`banner.gif/jpg/png` 이미지 파일을 사용하여 이미지 기반 배너를 출력할 수도 있습니다."
    },
    {
      "id": 167,
      "type": "descriptive",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot의 **`@ConditionalOnProperty`** 애노테이션의 역할과 사용 예시를 설명하세요.",
      "answer": "`@ConditionalOnProperty`는 `application.properties` (또는 yml)에 **특정 속성 값이 존재**하거나 **특정 값과 일치**할 때만 해당 Bean 또는 설정을 활성화하는 조건부 애노테이션입니다.\n예시: `@ConditionalOnProperty(name = \"my.feature.enabled\", havingValue = \"true\")`",
      "explanation": "주로 기능 플래그(Feature Flag)를 구현할 때 유용하게 사용됩니다."
    },
    {
      "id": 168,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "Spring Boot 2.7 이후, 자동 설정을 등록하기 위해 `META-INF/spring.factories` 파일 대신 권장되는 파일 경로는?",
      "choices": [
        "META-INF/spring.properties",
        "META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports",
        "META-INF/services/org.springframework.boot.autoconfigure.EnableAutoConfiguration",
        "META-INF/spring-autoconfigure.xml"
      ],
      "answer": "META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports",
      "explanation": "이 파일은 자동 설정 클래스의 FQCN(정규화된 클래스 이름) 목록을 포함하며, `spring.factories`보다 성능이 최적화되었습니다."
    },
    {
      "id": 169,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "beginner",
      "question": "Spring Boot 테스트에서 **`MockMvc`** 객체를 사용하는 주된 목적은 무엇입니까?",
      "answer": "실제 HTTP 서버를 실행하지 않고, **컨트롤러(Controller) 계층**을 대상으로 **가짜 HTTP 요청**을 보내고 응답을 검증하기 위해 사용됩니다.",
      "explanation": "빠르고 격리된 환경에서 MVC 동작을 테스트할 수 있습니다."
    },
    {
      "id": 170,
      "type": "descriptive",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "Spring Boot의 **`ApplicationRunner`**와 **`CommandLineRunner`** 인터페이스의 차이점을 설명하세요.",
      "answer": "두 인터페이스 모두 애플리케이션 시작 시 특정 로직을 실행하기 위해 사용됩니다. 유일한 차이점은 **`run` 메서드의 파라미터**입니다.\n* **`CommandLineRunner`**: `String... args` (원본 명령줄 인수 배열)\n* **`ApplicationRunner`**: `ApplicationArguments` (인수를 파싱하여 옵션(--)과 비옵션으로 구분한 객체)\n`ApplicationRunner`가 더 구조화된 인수를 제공합니다.",
      "explanation": "여러 Runner가 있을 경우 `@Order`로 실행 순서를 지정할 수 있습니다."
    },
    {
      "id": 171,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "`@PathVariable(\"id\") Long id`에서 URL 경로에 `id`가 포함되지 않아도 오류가 발생하지 않도록 하는 속성은?",
      "answer": "`@PathVariable(name = \"id\", required = false) Long id`",
      "explanation": "`required = false`로 설정하면 해당 경로 변수가 선택 사항이 됩니다. (단, URL 매핑이 `@GetMapping(\"/users/{id}\")`와 `@GetMapping(\"/users\")` 두 개로 분리되어야 할 수 있습니다.)"
    },
    {
      "id": 172,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Spring MVC의 `DispatcherServlet`에서 HTTP 요청을 **어떤 Controller(Handler)가 처리해야 할지** 결정하는 컴포넌트는?",
      "choices": [
        "HandlerAdapter",
        "HandlerMapping",
        "ViewResolver",
        "HandlerInterceptor"
      ],
      "answer": "HandlerMapping",
      "explanation": "`HandlerMapping`은 요청 URL, HTTP 메서드 등을 기반으로 적절한 핸들러(컨트롤러 메서드)를 찾아 매핑합니다."
    },
    {
      "id": 173,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "**`@RequestBody`**와 **`@ModelAttribute`**가 데이터를 바인딩하는 방식의 근본적인 차이점은?",
      "answer": "**`@RequestBody`**는 HTTP **Body**의 데이터(예: JSON)를 `HttpMessageConverter`를 통해 단일 객체로 변환하고, **`@ModelAttribute`**는 **Query String**이나 **Form Data**의 요청 파라미터를 객체의 필드에 바인딩합니다.",
      "explanation": "API 통신에는 @RequestBody, HTML 폼 제출에는 @ModelAttribute가 주로 사용됩니다."
    },
    {
      "id": 174,
      "type": "descriptive",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "Spring MVC에서 **`HandlerAdapter`**의 역할을 `HandlerMapping`과 연관지어 설명하세요.",
      "answer": "`HandlerMapping`이 요청을 처리할 **핸들러(Controller)**를 찾으면, `DispatcherServlet`은 이 핸들러를 **실행**하기 위해 `HandlerAdapter`에게 위임합니다. `HandlerAdapter`는 다양한 유형의 핸들러(애노테이션 기반 컨트롤러, HttpRequestHandler 등)를 **동일한 방식으로 호출**할 수 있도록 하는 어댑터 패턴의 구현체입니다.",
      "explanation": "예: `@RequestMapping` 기반 컨트롤러는 `RequestMappingHandlerAdapter`가 처리합니다."
    },
    {
      "id": 175,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Controller 메서드가 성공적으로 실행되었을 때, `200 OK`가 아닌 **특정 HTTP 상태 코드**(예: 201 Created)를 반환하도록 지정하는 애노테이션은?",
      "choices": [
        "@ResponseStatus",
        "@StatusCode",
        "@HttpCode",
        "@ResponseBody"
      ],
      "answer": "@ResponseStatus",
      "explanation": "예: `@PostMapping` 메서드에 `@ResponseStatus(HttpStatus.CREATED)`를 붙여 201 상태 코드를 반환할 수 있습니다."
    },
    {
      "id": 176,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "Controller가 View로 데이터를 전달하기 위해 사용하는, **Key-Value** 형태의 데이터를 담는 객체의 인터페이스 이름은?",
      "answer": "Model (또는 ModelMap, ModelAndView)",
      "explanation": "Controller 메서드의 파라미터로 `Model`을 선언하면 Spring이 주입해주며, `model.addAttribute(\"key\", value)`로 데이터를 추가합니다."
    },
    {
      "id": 177,
      "type": "descriptive",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Spring Boot 환경에서 템플릿 엔진으로 **Thymeleaf**가 **JSP**보다 선호되는 이유를 설명하세요.",
      "answer": "1) **독립 실행**: Thymeleaf는 HTML 파일로도 열리기 때문에 디자이너와의 협업이 용이합니다(Natural Templates).\n2) **JAR 배포**: JSP는 WAR 패키징 및 서블릿 컨테이너의 제약이 있지만, Thymeleaf는 내장 서버와 함께 JAR 파일로 쉽게 배포할 수 있습니다.\n3) **풍부한 기능**: 레이아웃, 확장 기능 등 현대적인 웹 개발에 필요한 기능을 더 잘 지원합니다.",
      "explanation": "Spring Boot는 JSP를 공식적으로 권장하지 않으며, Thymeleaf, FreeMarker 등을 권장합니다."
    },
    {
      "id": 178,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "URL 경로 세그먼트 내에 **Key-Value** 쌍의 파라미터(예: /cars/42;color=red)를 바인딩하는 데 사용하는 애노테이션은?",
      "choices": [
        "@RequestParam",
        "@PathVariable",
        "@MatrixVariable",
        "@RequestAttribute"
      ],
      "answer": "@MatrixVariable",
      "explanation": "@MatrixVariable은 세미콜론(;)으로 구분되는 경로 내 파라미터를 추출할 때 사용됩니다. (사용 빈도는 낮음)"
    },
    {
      "id": 179,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Controller에서 **`redirect:`** 시, URL에 노출되지 않는 **일회성 메시지(Flash Attribute)**를 전달하기 위해 사용하는 객체는?",
      "answer": "RedirectAttributes",
      "explanation": "`redirectAttributes.addFlashAttribute(\"message\", \"Success\")`로 추가하면, 리다이렉트된 페이지에서 해당 값을 한 번만 사용할 수 있습니다."
    },
    {
      "id": 180,
      "type": "descriptive",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "Spring MVC에서 **비동기 요청 처리**(`Callable`, `DeferredResult`)가 동작하는 원리를 간단히 설명하세요.",
      "answer": "Controller가 `Callable`이나 `DeferredResult`를 반환하면, **요청 스레드(Request Thread)**는 즉시 반환되어 다른 요청을 처리할 수 있게 됩니다(서블릿 스레드 해제). 실제 작업은 **별도의 스레드**에서 비동기로 수행되며, 작업이 완료되면 결과가 응답으로 전송됩니다.",
      "explanation": "이는 스레드 풀의 효율성을 높여 대규모 트래픽을 처리하는 데 도움을 줍니다."
    },
    {
      "id": 181,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "beginner",
      "question": "Spring Data JPA의 `findById()` 메서드가 엔티티 대신 **`Optional<T>`**를 반환하는 이유는 무엇입니까?",
      "answer": "조회하려는 ID에 해당하는 엔티티가 **존재하지 않을 경우(null)**를 명시적이고 안전하게 처리하기 위함입니다.",
      "explanation": "이를 통해 `NullPointerException`을 방지하고, `.orElseThrow()`, `.ifPresent()` 등 함수형 스타일의 처리가 가능합니다."
    },
    {
      "id": 182,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "JPA의 **`CascadeType.ALL`**이 포함하지 **않는** 영속성 전이 옵션은?",
      "choices": [
        "PERSIST (저장)",
        "MERGE (병합)",
        "REMOVE (삭제)",
        "DETACH (준영속)"
      ],
      "answer": "DETACH (준영속)",
      "explanation": "`CascadeType.ALL`은 `PERSIST`, `MERGE`, `REMOVE`, `REFRESH`를 포함합니다. `DETACH`는 별도로 지정해야 합니다. (JPA 2.0 기준, Hibernate는 DETACH 포함)"
    },
    {
      "id": 183,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "엔티티의 기본 타입(String, Integer 등)이나 `@Embeddable` 타입의 **컬렉션**을 매핑할 때 사용하는 애노테이션은?",
      "answer": "@ElementCollection",
      "explanation": "엔티티가 아닌 값 타입의 컬렉션을 별도의 테이블에 저장할 때 사용되며, 컬렉션의 생명주기가 엔티티에 완전히 종속됩니다."
    },
    {
      "id": 184,
      "type": "descriptive",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "**OSIV(Open-Session-In-View)** 또는 **(Open-EntityManager-In-View)** 패턴의 장단점을 설명하세요.",
      "answer": "**장점**: 트랜잭션 범위 밖(예: View 렌더링 시점)에서도 **지연 로딩(Lazy Loading)**을 사용할 수 있게 하여 `LazyInitializationException`을 방지합니다.\n**단점**: 영속성 컨텍스트가 **요청 내내** 열려있어, 불필요한 DB 커넥션 점유 시간이 길어지고, View에서 의도치 않은 변경 감지(Dirty Checking)가 발생할 수 있습니다.",
      "explanation": "Spring Boot는 OSIV를 기본값(true)으로 설정하지만, 성능 문제를 유발할 수 있어 `false`로 설정하고 트랜잭션 내에서 모든 로직을 처리하는 것을 권장합니다."
    },
    {
      "id": 185,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "Spring Data JPA의 `@Query` 애노테이션에서 **JPQL**이 아닌 **순수 SQL(Native SQL)**을 사용하도록 하는 속성은?",
      "choices": [
        "sql = true",
        "nativeQuery = true",
        "jpql = false",
        "value = \"NATIVE:...\""
      ],
      "answer": "nativeQuery = true",
      "explanation": "`@Query(value = \"SELECT * FROM users WHERE name = ?1\", nativeQuery = true)`와 같이 사용하여 특정 DB에 종속적인 SQL을 실행할 수 있습니다."
    },
    {
      "id": 186,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "Spring Data JPA에서 **동적 쿼리(Dynamic Query)**를 타입-안전하게(type-safe) 작성할 수 있도록 도와주는 **`Specification`** 인터페이스는 어떤 패턴을 기반으로 합니까?",
      "answer": "Criteria API (JPA의 동적 쿼리 명세) 또는 Specification 패턴",
      "explanation": "`Specification` 인터페이스를 구현하여 복잡한 `WHERE` 절을 조합하고, `JpaSpecificationExecutor`를 통해 실행할 수 있습니다."
    },
    {
      "id": 187,
      "type": "descriptive",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "Spring Data JPA의 **쿼리 메서드(Query by Method Name)** 기능을 예시와 함께 설명하세요.",
      "answer": "Repository 인터페이스에 **정해진 명명 규칙**에 따라 메서드를 선언하면, Spring Data JPA가 메서드 이름을 분석하여 자동으로 JPQL 쿼리를 생성하는 기능입니다.\n예시: `findByNameAndAgeGreaterThan(String name, int age)`",
      "explanation": "간단한 쿼리는 JPQL 작성 없이 메서드 선언만으로 구현할 수 있습니다."
    },
    {
      "id": 188,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "JPA의 **2차 캐시(Second-Level Cache)**에 대한 설명으로 올바른 것은?",
      "choices": [
        "기본적으로 활성화되어 있다.",
        "트랜잭션(영속성 컨텍스트) 범위 내에서만 동작한다.",
        "여러 트랜잭션 간에 공유되며, 애플리케이션 레벨에서 동작한다.",
        "엔티티의 일부 필드만 캐시할 수 있다."
      ],
      "answer": "여러 트랜잭션 간에 공유되며, 애플리케이션 레벨에서 동작한다.",
      "explanation": "2차 캐시는 `EntityManagerFactory` 레벨에서 동작하며, 여러 세션/트랜잭션 간에 공유됩니다. (1차 캐시는 `EntityManager` 레벨) 기본적으로 비활성화되어 있으며, EhCache, Infinispan 등 구현체 설정이 필요합니다."
    },
    {
      "id": 189,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "Spring Data JPA의 Auditing 기능을 활성화하기 위해 엔티티 클래스에 추가하는 애노테이션은?",
      "answer": "@EntityListeners(AuditingEntityListener.class)",
      "explanation": "이 애노테이션은 해당 엔티티가 `@CreatedDate`, `@LastModifiedDate`와 같은 Auditing 이벤트를 수신할 것임을 선언합니다."
    },
    {
      "id": 190,
      "type": "descriptive",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "**`FetchType.EAGER` (즉시 로딩)** 전략이 유발할 수 있는 성능 문제점을 설명하세요.",
      "answer": "즉시 로딩은 해당 엔티티를 조회할 때 연관된 모든 엔티티를 **항상 함께** 조회합니다. 만약 연관 엔티티가 많거나 당장 필요하지 않은 경우에도 불필요한 조인 쿼리가 발생하거나, **N+1 문제**를 유발하여 심각한 성능 저하를 일으킬 수 있습니다.",
      "explanation": "모든 연관 관계는 `FetchType.LAZY` (지연 로딩)로 설정하고, 필요할 때만 Fetch Join을 사용하는 것이 권장됩니다."
    },
    {
      "id": 191,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "beginner",
      "question": "Spring Security에서 가장 널리 사용되는, 안전한 비밀번호 해싱을 위한 `PasswordEncoder` 구현체는?",
      "answer": "BCryptPasswordEncoder",
      "explanation": "BCrypt는 솔트(Salt)를 포함하고 여러 번의 해시를 반복(Key Stretching)하여 무차별 대입 공격(Brute-force)에 강합니다."
    },
    {
      "id": 192,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security의 `HttpSecurity` 설정에서 **`antMatchers()`**와 **`mvcMatchers()`**의 차이점은?",
      "choices": [
        "antMatchers()는 더 빠르고, mvcMatchers()는 느리다.",
        "antMatchers()는 Ant 스타일 경로 패턴, mvcMatchers()는 Spring MVC의 핸들러 매핑 정보를 사용한다.",
        "antMatchers()는 XML에서만, mvcMatchers()는 Java Config에서만 사용된다.",
        "차이가 없다."
      ],
      "answer": "antMatchers()는 Ant 스타일 경로 패턴, mvcMatchers()는 Spring MVC의 핸들러 매핑 정보를 사용한다.",
      "explanation": "`mvcMatchers()`는 `@PathVariable` 등을 인식하고, 서블릿 컨텍스트 경로를 고려하는 등 더 정확한 매칭이 가능합니다."
    },
    {
      "id": 193,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security의 `SecurityContextHolder.getContext().getAuthentication()` 메서드가 반환하는 **`Authentication`** 객체의 두 가지 주요 정보는?",
      "answer": "1) **Principal (주체)**: 현재 인증된 사용자 (주로 UserDetails 객체 또는 사용자 이름)\n2) **Authorities (권한)**: 해당 주체가 가진 권한 목록",
      "explanation": "이 객체를 통해 현재 사용자의 정보와 권한을 어디서든 접근할 수 있습니다."
    },
    {
      "id": 194,
      "type": "descriptive",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "OAuth 2.0의 **Client Credentials Grant** 흐름은 언제 사용되며, 이 흐름에는 누가 참여하지 않습니까?",
      "answer": "Client Credentials Grant는 **사용자(Resource Owner)가 관여하지 않는** 서버 간(Machine-to-Machine) 통신이나 백엔드 서비스 간의 인증에 사용됩니다. 이 흐름에는 **사용자의 개입이 전혀 없습니다**.",
      "explanation": "클라이언트 ID와 시크릿만으로 Access Token을 발급받아 API를 호출합니다."
    },
    {
      "id": 195,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring MVC의 Controller 메서드 파라미터에서, 현재 인증된 사용자의 **`Principal`** 객체(주로 `UserDetails`)를 직접 주입받는 애노테이션은?",
      "choices": [
        "@Principal",
        "@CurrentUser",
        "@AuthenticationPrincipal",
        "@SecuredPrincipal"
      ],
      "answer": "@AuthenticationPrincipal",
      "explanation": "`@AuthenticationPrincipal`을 사용하면 `SecurityContextHolder`를 통하지 않고도 인증된 사용자 객체를 편리하게 주입받을 수 있습니다."
    },
    {
      "id": 196,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "Spring Security에서 **JWT 토큰 필터**를 구현할 때, **`OncePerRequestFilter`**를 상속받는 주된 이유는 무엇입니까?",
      "answer": "서블릿 컨테이너의 요청 처리 과정에서 필터가 **여러 번 호출되는 것을 방지**하고, **요청 당 단 한 번만** 실행되도록 보장하기 위함입니다.",
      "explanation": "특히 내부 포워딩(forward)이나 인클루드(include) 발생 시 필터가 중복 실행되는 것을 막아줍니다."
    },
    {
      "id": 197,
      "type": "descriptive",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 **`http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)`** 설정은 무엇을 의미하며, 주로 어떤 환경에서 사용됩니까?",
      "answer": "이 설정은 Spring Security가 **HTTP 세션을 전혀 생성하지도, 사용하지도 않도록** 강제하는 **무상태(Stateless)** 정책을 의미합니다. \n주로 **JWT 토큰 기반**의 **REST API 서버** 환경에서 사용됩니다.",
      "explanation": "세션을 사용하지 않음으로써 서버의 수평 확장(Scale-out)이 용이해집니다."
    },
    {
      "id": 198,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "Spring Security의 인가(Authorization) 과정에서 '이 요청을 허용할 것인가'를 **실제로 투표(vote)**하는 컴포넌트는?",
      "choices": [
        "AccessDecisionManager",
        "AccessDecisionVoter",
        "AuthenticationManager",
        "AuthenticationProvider"
      ],
      "answer": "AccessDecisionVoter",
      "explanation": "`AccessDecisionVoter` (예: `RoleVoter`, `WebExpressionVoter`)가 투표하고, `AccessDecisionManager`가 이 투표 결과를 취합하여 최종 결정을 내립니다."
    },
    {
      "id": 199,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "beginner",
      "question": "`HttpSecurity` 설정에서 `authorizeRequests()` (또는 `authorizeHttpRequests()`) 메서드의 역할은?",
      "answer": "HTTP 요청에 대한 **인가(Authorization) 규칙**, 즉 URL 경로별 접근 권한(예: `permitAll`, `hasRole`, `authenticated`)을 설정하는 부분의 시작을 의미합니다.",
      "explanation": "Spring Security 설정의 핵심 부분 중 하나입니다."
    },
    {
      "id": 200,
      "type": "descriptive",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "**JWT(Json Web Token)**를 구성하는 세 가지 요소(Header, Payload, Signature)와 각각의 역할을 설명하세요.",
      "answer": "1) **Header (헤더)**: 토큰의 타입(예: JWT)과 서명에 사용된 해시 알고리즘(예: HS256) 정보를 담습니다.\n2) **Payload (페이로드)**: 토큰의 실제 내용(데이터)인 **Claims**를 담습니다. (예: 사용자 ID, 권한, 만료 시간)\n3) **Signature (서명)**: 헤더와 페이로드를 인코딩한 값과 **비밀 키(Secret Key)**를 사용하여 생성한 서명 값입니다. 토큰의 **무결성**과 **인증**을 보장합니다.",
      "explanation": "서명(Signature)이 있기 때문에 페이로드의 내용은 누구나 볼 수 있지만, 위변조는 불가능합니다."
    }
  ]
}