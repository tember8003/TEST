{
  "questions": [
    {
      "id": 46,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "Spring Bean의 기본 스코프(scope)가 아닌 것은 무엇입니까?",
      "choices": [
        "singleton",
        "prototype",
        "session",
        "application"
      ],
      "answer": "application",
      "explanation": "Spring Bean의 5가지 스코프는 singleton, prototype, request, session, global-session입니다. 'application'은 존재하지 않는 스코프입니다."
    },
    {
      "id": 47,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "BeanFactory와 ApplicationContext 중 어느 것이 더 자주 사용되며, 그 이유는 무엇입니까?",
      "answer": "ApplicationContext가 더 자주 사용됩니다. BeanFactory를 확장하여 이벤트 전파, AOP, 국제화 지원 등 더 많은 엔터프라이즈 기능을 제공하기 때문입니다.",
      "explanation": "ApplicationContext는 BeanFactory의 모든 기능을 포함하면서 추가적인 엔터프라이즈 기능을 제공하므로 실무에서 선호됩니다."
    },
    {
      "id": 48,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "다음 중 Inner Bean에 대한 설명으로 올바른 것은?",
      "choices": [
        "항상 singleton 스코프를 가진다",
        "항상 prototype 스코프를 가진다",
        "ID를 반드시 지정해야 한다",
        "다른 Bean에서도 참조할 수 있다"
      ],
      "answer": "항상 prototype 스코프를 가진다",
      "explanation": "Inner Bean은 항상 익명이며 prototype 스코프를 가집니다. 다른 Bean의 속성으로만 사용됩니다."
    },
    {
      "id": 49,
      "type": "descriptive",
      "category": "Spring Core",
      "difficulty": "advanced",
      "question": "Spring AOP에서 Advice의 5가지 타입을 설명하고, 각각의 사용 사례를 제시하세요.",
      "answer": "1) Before: 메서드 실행 전 (로깅, 권한 체크), 2) After Returning: 메서드 정상 완료 후 (결과 로깅), 3) After Throwing: 예외 발생 시 (에러 로깅), 4) After(Finally): 성공/실패 상관없이 실행 후 (리소스 정리), 5) Around: 메서드 실행 전후 제어 (트랜잭션, 성능 측정)",
      "explanation": "각 Advice 타입은 메서드 실행의 다른 시점에 실행되며, 횡단 관심사를 모듈화하는 데 사용됩니다."
    },
    {
      "id": 50,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "Spring에서 Autowiring 모드가 아닌 것은?",
      "choices": [
        "byName",
        "byType",
        "constructor",
        "byClass"
      ],
      "answer": "byClass",
      "explanation": "Spring의 Autowiring 모드는 no, byName, byType, constructor, autodetect입니다. byClass는 존재하지 않습니다."
    },
    {
      "id": 51,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "Spring Framework에서 'Inversion of Control'의 의미를 간단히 설명하세요.",
      "answer": "객체의 생성과 생명주기 관리를 개발자가 아닌 Spring Container가 제어하는 것을 의미합니다.",
      "explanation": "IoC는 제어의 역전으로, 객체 간의 결합도를 낮추고 유연성을 높입니다."
    },
    {
      "id": 52,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "다음 중 Bean 생명주기 콜백 메서드 호출 순서가 올바른 것은?",
      "choices": [
        "Constructor → @PostConstruct → InitializingBean.afterPropertiesSet() → init-method",
        "@PostConstruct → Constructor → InitializingBean.afterPropertiesSet() → init-method",
        "Constructor → InitializingBean.afterPropertiesSet() → @PostConstruct → init-method",
        "init-method → Constructor → @PostConstruct → InitializingBean.afterPropertiesSet()"
      ],
      "answer": "Constructor → @PostConstruct → InitializingBean.afterPropertiesSet() → init-method",
      "explanation": "생성자가 먼저 호출되고, @PostConstruct, InitializingBean 인터페이스, 마지막으로 init-method 순서로 실행됩니다."
    },
    {
      "id": 53,
      "type": "descriptive",
      "category": "Spring Core",
      "difficulty": "advanced",
      "question": "FactoryBean과 일반 Bean의 차이점을 설명하고, FactoryBean을 사용하는 시나리오를 제시하세요.",
      "answer": "FactoryBean은 복잡한 초기화 로직이 필요한 Bean을 생성하는 팩토리 역할을 합니다. getObject() 메서드로 실제 Bean을 반환하며, 프록시 객체나 외부 리소스를 래핑한 Bean을 생성할 때 유용합니다.",
      "explanation": "FactoryBean은 Bean 생성 과정을 커스터마이즈할 수 있는 인터페이스로, 복잡한 초기화가 필요한 경우 사용됩니다."
    },
    {
      "id": 54,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "beginner",
      "question": "@Component, @Service, @Repository, @Controller 중 데이터 액세스 계층에 사용되는 애노테이션은?",
      "choices": [
        "@Component",
        "@Service",
        "@Repository",
        "@Controller"
      ],
      "answer": "@Repository",
      "explanation": "@Repository는 데이터 액세스 계층을 나타내며, 영속성 예외를 Spring의 DataAccessException으로 변환하는 기능을 제공합니다."
    },
    {
      "id": 55,
      "type": "short_answer",
      "category": "Spring Core",
      "difficulty": "intermediate",
      "question": "Spring에서 Circular Dependency가 발생하는 상황과 해결 방법을 설명하세요.",
      "answer": "두 개 이상의 Bean이 서로를 의존할 때 발생합니다. 해결 방법으로는 @Lazy 애노테이션 사용, setter 주입으로 변경, 또는 리팩토링하여 순환 의존성을 제거하는 방법이 있습니다.",
      "explanation": "생성자 주입에서 순환 의존성이 발생하면 BeanCurrentlyInCreationException이 발생합니다."
    },
    {
      "id": 56,
      "type": "multiple_choice",
      "category": "Spring Core",
      "difficulty": "advanced",
      "question": "Spring AOP에서 JDK Dynamic Proxy와 CGLIB Proxy의 주요 차이점은?",
      "choices": [
        "JDK는 인터페이스 기반, CGLIB는 클래스 기반",
        "JDK는 클래스 기반, CGLIB는 인터페이스 기반",
        "JDK는 더 빠르고, CGLIB는 더 느리다",
        "둘 다 동일한 방식으로 동작한다"
      ],
      "answer": "JDK는 인터페이스 기반, CGLIB는 클래스 기반",
      "explanation": "JDK Dynamic Proxy는 인터페이스를 구현한 클래스에만 사용 가능하고, CGLIB는 구체 클래스를 상속하여 프록시를 생성합니다."
    },
    {
      "id": 57,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "beginner",
      "question": "@SpringBootApplication 애노테이션이 포함하지 않는 것은?",
      "choices": [
        "@Configuration",
        "@EnableAutoConfiguration",
        "@ComponentScan",
        "@RestController"
      ],
      "answer": "@RestController",
      "explanation": "@SpringBootApplication은 @Configuration, @EnableAutoConfiguration, @ComponentScan을 결합한 편리한 애노테이션입니다."
    },
    {
      "id": 58,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "beginner",
      "question": "Spring Boot의 'Starter' 의존성의 주요 목적은 무엇입니까?",
      "answer": "관련된 여러 의존성을 그룹화하여 한 번에 추가할 수 있도록 하고, 버전 호환성 문제를 해결하여 빠른 개발을 가능하게 합니다.",
      "explanation": "예를 들어 spring-boot-starter-web은 웹 개발에 필요한 모든 의존성을 포함합니다."
    },
    {
      "id": 59,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot Actuator의 기본 엔드포인트가 아닌 것은?",
      "choices": [
        "/actuator/health",
        "/actuator/info",
        "/actuator/metrics",
        "/actuator/restart"
      ],
      "answer": "/actuator/restart",
      "explanation": "Actuator는 health, info, metrics 등을 제공하지만 restart 엔드포인트는 기본 제공하지 않습니다."
    },
    {
      "id": 60,
      "type": "descriptive",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "Spring Boot의 Auto Configuration이 조건부로 활성화되는 원리를 @ConditionalOnClass를 예로 들어 설명하세요.",
      "answer": "@ConditionalOnClass는 특정 클래스가 클래스패스에 존재할 때만 해당 설정을 활성화합니다. 예를 들어 DataSourceAutoConfiguration은 @ConditionalOnClass(DataSource.class)로 JDBC 드라이버가 있을 때만 DataSource Bean을 생성합니다.",
      "explanation": "이를 통해 불필요한 설정이 로드되지 않고, 프로젝트에 필요한 설정만 자동으로 적용됩니다."
    },
    {
      "id": 61,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot에서 외부 설정 우선순위가 가장 높은 것은?",
      "choices": [
        "application.properties",
        "시스템 환경 변수",
        "명령줄 인수",
        "@PropertySource"
      ],
      "answer": "명령줄 인수",
      "explanation": "명령줄 인수가 가장 높은 우선순위를 가지며, 다음으로 환경 변수, application.properties 순입니다."
    },
    {
      "id": 62,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "beginner",
      "question": "Spring Boot DevTools의 주요 기능 3가지를 나열하세요.",
      "answer": "1) 자동 재시작 (코드 변경 시), 2) LiveReload (브라우저 자동 새로고침), 3) 개발 환경 설정 자동 적용",
      "explanation": "DevTools는 개발 생산성을 높이기 위한 도구입니다."
    },
    {
      "id": 63,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "Spring Boot에서 Profile을 활성화하는 방법이 아닌 것은?",
      "choices": [
        "spring.profiles.active 속성 설정",
        "명령줄에서 --spring.profiles.active=dev",
        "환경 변수 SPRING_PROFILES_ACTIVE",
        "@EnableProfile 애노테이션"
      ],
      "answer": "@EnableProfile 애노테이션",
      "explanation": "Profile 활성화는 @Profile 애노테이션으로 Bean에 지정하고, spring.profiles.active로 활성화합니다. @EnableProfile은 존재하지 않습니다."
    },
    {
      "id": 64,
      "type": "descriptive",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "Spring Boot에서 임베디드 Tomcat의 설정을 커스터마이징하는 방법을 설명하세요.",
      "answer": "1) application.properties에서 server.* 속성으로 포트, 컨텍스트 경로 등 설정, 2) WebServerFactoryCustomizer 인터페이스를 구현하여 프로그래밍 방식으로 설정, 3) TomcatServletWebServerFactory Bean을 직접 정의하여 커넥터, 밸브 등 세밀한 설정",
      "explanation": "임베디드 서버 설정은 여러 방법으로 커스터마이징할 수 있으며, 용도에 따라 적절한 방법을 선택합니다."
    },
    {
      "id": 65,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "beginner",
      "question": "Spring Boot에서 JAR 파일을 실행 가능하게 만드는 것은?",
      "choices": [
        "spring-boot-maven-plugin",
        "spring-boot-loader",
        "executable-jar",
        "fat-jar"
      ],
      "answer": "spring-boot-maven-plugin",
      "explanation": "spring-boot-maven-plugin은 모든 의존성을 포함한 실행 가능한 JAR를 생성합니다."
    },
    {
      "id": 66,
      "type": "short_answer",
      "category": "Spring Boot",
      "difficulty": "intermediate",
      "question": "@ConfigurationProperties와 @Value의 차이점과 각각의 사용 시나리오를 설명하세요.",
      "answer": "@Value는 개별 속성을 주입할 때, @ConfigurationProperties는 관련된 여러 속성을 객체로 그룹화할 때 사용합니다. 후자는 타입 안정성과 유효성 검증이 가능합니다.",
      "explanation": "@ConfigurationProperties는 복잡한 설정을 구조화하는 데 적합하며, IDE 자동 완성도 지원합니다."
    },
    {
      "id": 67,
      "type": "multiple_choice",
      "category": "Spring Boot",
      "difficulty": "advanced",
      "question": "Spring Boot에서 Conditional 애노테이션으로 할 수 없는 것은?",
      "choices": [
        "특정 Bean이 존재할 때만 활성화",
        "특정 속성 값이 있을 때만 활성화",
        "특정 Profile이 활성화되었을 때만 활성화",
        "특정 날짜 이후에만 활성화"
      ],
      "answer": "특정 날짜 이후에만 활성화",
      "explanation": "Conditional 애노테이션은 Bean, 속성, Profile, 클래스 존재 여부 등을 확인하지만, 날짜 기반 조건은 지원하지 않습니다."
    },
    {
      "id": 68,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "Spring MVC에서 클라이언트의 HTTP 요청을 가장 먼저 받는 컴포넌트는?",
      "choices": [
        "Controller",
        "HandlerMapping",
        "DispatcherServlet",
        "ViewResolver"
      ],
      "answer": "DispatcherServlet",
      "explanation": "DispatcherServlet은 Front Controller 패턴을 구현하며, 모든 요청을 받아 적절한 핸들러로 전달합니다."
    },
    {
      "id": 69,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "@RequestParam과 @PathVariable의 차이점을 예제와 함께 설명하세요.",
      "answer": "@RequestParam은 쿼리 스트링(?name=value)에서 값을 추출하고, @PathVariable은 URL 경로(/users/{id})에서 값을 추출합니다.",
      "explanation": "예: /users?id=10 → @RequestParam, /users/10 → @PathVariable"
    },
    {
      "id": 70,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "다음 중 RESTful API에서 리소스 생성에 적합한 HTTP 메서드와 상태 코드는?",
      "choices": [
        "GET - 200 OK",
        "POST - 201 Created",
        "PUT - 200 OK",
        "DELETE - 204 No Content"
      ],
      "answer": "POST - 201 Created",
      "explanation": "POST는 새로운 리소스를 생성하며, 성공 시 201 Created와 Location 헤더를 반환하는 것이 표준입니다."
    },
    {
      "id": 71,
      "type": "descriptive",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "Spring MVC에서 요청 처리 흐름을 DispatcherServlet부터 View 렌더링까지 단계별로 설명하세요.",
      "answer": "1) DispatcherServlet이 요청 수신 → 2) HandlerMapping이 적절한 Controller 결정 → 3) HandlerAdapter가 Controller 메서드 실행 → 4) Controller가 ModelAndView 반환 → 5) ViewResolver가 View 이름을 실제 View로 해석 → 6) View가 Model 데이터로 렌더링 → 7) 응답 반환",
      "explanation": "이 흐름은 Spring MVC의 핵심 동작 원리이며, 각 컴포넌트가 명확한 책임을 가집니다."
    },
    {
      "id": 72,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "@RestController와 @Controller의 주요 차이점은?",
      "choices": [
        "@RestController는 @Controller + @ResponseBody",
        "@RestController는 JSON만 반환",
        "@Controller는 REST API 전용",
        "기능적 차이 없음"
      ],
      "answer": "@RestController는 @Controller + @ResponseBody",
      "explanation": "@RestController는 모든 메서드에 @ResponseBody가 자동으로 적용되어, View가 아닌 데이터를 직접 반환합니다."
    },
    {
      "id": 73,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Spring MVC에서 @ModelAttribute의 역할과 사용 시나리오를 설명하세요.",
      "answer": "@ModelAttribute는 폼 데이터를 객체로 바인딩하거나, 여러 핸들러 메서드에서 공통으로 사용할 데이터를 Model에 추가할 때 사용합니다.",
      "explanation": "메서드 레벨에서는 Model에 공통 속성 추가, 파라미터 레벨에서는 폼 데이터 바인딩에 사용됩니다."
    },
    {
      "id": 74,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "Spring MVC에서 파일 업로드를 처리하기 위해 필요한 Bean은?",
      "choices": [
        "FileUploadResolver",
        "MultipartResolver",
        "FileResolver",
        "UploadResolver"
      ],
      "answer": "MultipartResolver",
      "explanation": "MultipartResolver는 multipart 요청을 파싱하여 업로드된 파일을 추출합니다. StandardServletMultipartResolver 또는 CommonsMultipartResolver를 사용합니다."
    },
    {
      "id": 75,
      "type": "descriptive",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "Spring MVC에서 Interceptor와 Filter의 차이점과 각각의 사용 사례를 설명하세요.",
      "answer": "Filter는 Servlet 스펙으로 DispatcherServlet 이전에 실행되며, 인코딩, XSS 방어 등에 사용됩니다. Interceptor는 Spring MVC 기능으로 Controller 실행 전후에 실행되며, 인증/인가, 로깅, 공통 Model 데이터 추가에 사용됩니다. Interceptor는 Spring Bean 주입이 가능합니다.",
      "explanation": "Filter는 Servlet Container 레벨, Interceptor는 Spring Context 레벨에서 동작합니다."
    },
    {
      "id": 76,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "@RequestMapping의 속성이 아닌 것은?",
      "choices": [
        "value",
        "method",
        "params",
        "timeout"
      ],
      "answer": "timeout",
      "explanation": "@RequestMapping은 value(경로), method(HTTP 메서드), params(파라미터 조건), headers(헤더 조건) 등을 속성으로 가지지만 timeout은 없습니다."
    },
    {
      "id": 77,
      "type": "short_answer",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Spring MVC에서 Content Negotiation이란 무엇이며, 어떻게 동작합니까?",
      "answer": "클라이언트가 요청한 형식(JSON, XML 등)에 맞춰 응답을 변환하는 기능입니다. Accept 헤더나 URL 확장자를 보고 적절한 HttpMessageConverter를 선택합니다.",
      "explanation": "예를 들어 Accept: application/json이면 MappingJackson2HttpMessageConverter가 사용됩니다."
    },
    {
      "id": 78,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Spring MVC에서 @Valid 애노테이션의 역할은?",
      "choices": [
        "메서드 실행 전 권한 검증",
        "요청 데이터의 유효성 검증",
        "Bean 생성 시 유효성 검증",
        "SQL Injection 방어"
      ],
      "answer": "요청 데이터의 유효성 검증",
      "explanation": "@Valid는 JSR-303 Bean Validation을 트리거하여, @NotNull, @Size 등의 애노테이션으로 정의된 제약 조건을 검증합니다."
    },
    {
      "id": 79,
      "type": "descriptive",
      "category": "Spring MVC",
      "difficulty": "advanced",
      "question": "Spring MVC에서 비동기 요청 처리를 위한 DeferredResult와 Callable의 차이점을 설명하세요.",
      "answer": "Callable은 Spring이 관리하는 별도 스레드에서 실행되며, 결과가 준비될 때까지 비동기로 처리됩니다. DeferredResult는 개발자가 직접 언제 결과를 설정할지 제어하며, 외부 이벤트나 메시지 큐의 응답을 기다릴 때 유용합니다. Callable은 간단한 비동기 처리에, DeferredResult는 복잡한 비동기 흐름에 적합합니다.",
      "explanation": "둘 다 비동기 요청 처리를 지원하지만, 제어 수준과 사용 사례가 다릅니다."
    },
    {
      "id": 80,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "intermediate",
      "question": "Spring MVC에서 @ExceptionHandler의 적용 범위는?",
      "choices": [
        "전역 (모든 Controller)",
        "동일한 Controller 내",
        "동일한 패키지 내",
        "동일한 모듈 내"
      ],
      "answer": "동일한 Controller 내",
      "explanation": "@ExceptionHandler는 해당 Controller 내에서만 동작합니다. 전역 처리를 위해서는 @ControllerAdvice를 사용해야 합니다."
    },
    {
      "id": 81,
      "type": "multiple_choice",
      "category": "Spring MVC",
      "difficulty": "beginner",
      "question": "Spring MVC에서 정적 리소스(CSS, JS, 이미지)를 제공하는 기본 경로는?",
      "choices": [
        "/static",
        "/public",
        "/resources",
        "위 모두 가능"
      ],
      "answer": "위 모두 가능",
      "explanation": "Spring Boot는 /static, /public, /resources, /META-INF/resources 디렉토리를 자동으로 정적 리소스 경로로 인식합니다."
    },
    {
      "id": 82,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "beginner",
      "question": "JPA에서 @Entity 애노테이션의 필수 요구사항이 아닌 것은?",
      "choices": [
        "기본 생성자",
        "@Id 필드",
        "final 클래스 아님",
        "Serializable 구현"
      ],
      "answer": "Serializable 구현",
      "explanation": "@Entity는 기본 생성자, @Id, non-final 클래스를 요구하지만, Serializable 구현은 선택 사항입니다."
    },
    {
      "id": 83,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "JPA의 1차 캐시(영속성 컨텍스트)와 2차 캐시의 차이점을 설명하세요.",
      "answer": "1차 캐시는 EntityManager 레벨에서 동작하며 트랜잭션 단위로 생명주기를 가집니다. 2차 캐시는 EntityManagerFactory 레벨에서 동작하며 애플리케이션 전체에서 공유됩니다.",
      "explanation": "1차 캐시는 기본 제공, 2차 캐시는 별도 설정이 필요하며 성능 향상을 위해 사용됩니다."
    },
    {
      "id": 84,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "Spring Data JPA에서 쿼리 메서드 이름 규칙으로 올바르지 않은 것은?",
      "choices": [
        "findByName",
        "findByNameAndAge",
        "findByNameOrAge",
        "findByNameWithAge"
      ],
      "answer": "findByNameWithAge",
      "explanation": "Spring Data JPA는 And, Or 키워드를 지원하지만 With는 지원하지 않습니다."
    },
    {
      "id": 85,
      "type": "descriptive",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "JPA에서 @OneToMany 관계의 N+1 문제를 해결하는 3가지 방법을 설명하세요.",
      "answer": "1) Fetch Join: JPQL에서 'JOIN FETCH'로 한 번에 조회, 2) @EntityGraph: attributePaths로 함께 로드할 엔티티 지정, 3) @BatchSize: 지연 로딩 시 N개를 한 번에 IN절로 조회. Fetch Join이 가장 명확하지만 페이징과 함께 사용 불가, BatchSize는 페이징 가능합니다.",
      "explanation": "N+1 문제는 연관 엔티티를 개별 조회하여 발생하며, 한 번에 조회하도록 최적화해야 합니다."
    },
    {
      "id": 86,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "intermediate",
      "question": "@Transactional의 기본 전파(Propagation) 속성은?",
      "choices": [
        "REQUIRED",
        "REQUIRES_NEW",
        "NESTED",
        "MANDATORY"
      ],
      "answer": "REQUIRED",
      "explanation": "REQUIRED는 진행 중인 트랜잭션이 있으면 참여하고, 없으면 새로 시작하는 기본 전파 방식입니다."
    },
    {
      "id": 87,
      "type": "short_answer",
      "category": "Spring Data JPA",
      "difficulty": "beginner",
      "question": "JPA에서 @GeneratedValue의 IDENTITY, SEQUENCE, TABLE, AUTO 전략의 차이점을 간단히 설명하세요.",
      "answer": "IDENTITY는 DB의 AUTO_INCREMENT, SEQUENCE는 DB 시퀀스 사용, TABLE은 키 생성 전용 테이블 사용, AUTO는 DB에 따라 자동 선택합니다.",
      "explanation": "MySQL은 IDENTITY, Oracle/PostgreSQL은 SEQUENCE를 주로 사용합니다."
    },
    {
      "id": 88,
      "type": "multiple_choice",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "JPA에서 Pessimistic Lock과 Optimistic Lock의 주요 차이점은?",
      "choices": [
        "Pessimistic은 DB Lock, Optimistic은 Version 체크",
        "Pessimistic은 빠르고, Optimistic은 느리다",
        "Pessimistic은 읽기 전용, Optimistic은 쓰기 전용",
        "둘 다 동일한 방식"
      ],
      "answer": "Pessimistic은 DB Lock, Optimistic은 Version 체크",
      "explanation": "Pessimistic Lock은 SELECT FOR UPDATE로 DB 레벨 Lock, Optimistic Lock은 @Version으로 충돌 감지 후 재시도합니다."
    },
    {
      "id": 89,
      "type": "descriptive",
      "category": "Spring Data JPA",
      "difficulty": "advanced",
      "question": "JPA의 영속성 전이(Cascade)와 고아 객체 제거(orphanRemoval)의 차이점과 사용 시나리오를 설명하세요.",
      "answer": "Cascade는 부모 엔티티의 변경사항을 자식에게 전파(PERSIST, REMOVE 등)하고, orphanRemoval은 부모와의 관계가 끊어진 자식을 자동 삭제합니다. Cascade.REMOVE는 부모 삭제 시 자식도 삭제, orphanRemoval=true는 컬렉션에서 제거한 자식도 삭제합니다. 둘을 함께 사용하면 완전한 생명주기 관리가 가능합니다.",
      "explanation": "주로 부모-자식 관계에서 일관성 유지를 위해 사용됩니다."
    },
    {
      "id": 90,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "beginner",
      "question": "Spring Security에서 사용자 인증 정보를 저장하는 인터페이스는?",
      "choices": [
        "UserDetails",
        "Authentication",
        "Principal",
        "GrantedAuthority"
      ],
      "answer": "UserDetails",
      "explanation": "UserDetails는 사용자 정보(username, password, authorities)를 담는 인터페이스입니다."
    },
    {
      "id": 91,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 CSRF 보호가 필요한 이유와 기본 동작 방식을 설명하세요.",
      "answer": "CSRF는 사용자가 의도하지 않은 요청을 실행하도록 유도하는 공격입니다. Spring Security는 상태 변경 요청(POST, PUT, DELETE)에 CSRF 토큰을 요구하여, 토큰이 일치하지 않으면 요청을 거부합니다.",
      "explanation": "CSRF 토큰은 서버에서 생성되어 클라이언트에 전달되며, 다음 요청 시 검증됩니다."
    },
    {
      "id": 92,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security의 Filter Chain에서 UsernamePasswordAuthenticationFilter가 수행하는 역할은?",
      "choices": [
        "JWT 토큰 검증",
        "폼 로그인 처리",
        "OAuth2 인증",
        "CSRF 토큰 검증"
      ],
      "answer": "폼 로그인 처리",
      "explanation": "UsernamePasswordAuthenticationFilter는 /login 엔드포인트로의 폼 기반 로그인 요청을 처리합니다."
    },
    {
      "id": 93,
      "type": "descriptive",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "Spring Security에서 JWT 기반 인증을 구현하는 과정을 Filter, TokenProvider, UserDetailsService 관점에서 설명하세요.",
      "answer": "1) 커스텀 JwtAuthenticationFilter에서 Authorization 헤더의 JWT 추출 → 2) TokenProvider가 토큰 유효성 검증 및 Claims 파싱 → 3) UserDetailsService가 사용자 정보 로드 → 4) Authentication 객체 생성 후 SecurityContext에 저장 → 5) 이후 요청에서 SecurityContext에서 인증 정보 사용",
      "explanation": "Stateless 방식으로 매 요청마다 토큰을 검증하여 인증 상태를 유지합니다."
    },
    {
      "id": 94,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 hasRole('ADMIN')과 hasAuthority('ROLE_ADMIN')의 차이는?",
      "choices": [
        "hasRole은 'ROLE_' 접두사 자동 추가",
        "hasAuthority가 더 강력한 권한",
        "hasRole은 deprecated됨",
        "기능적 차이 없음"
      ],
      "answer": "hasRole은 'ROLE_' 접두사 자동 추가",
      "explanation": "hasRole('ADMIN')은 내부적으로 'ROLE_ADMIN'으로 변환됩니다. hasAuthority는 그대로 사용합니다."
    },
    {
      "id": 95,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "beginner",
      "question": "Spring Security에서 @PreAuthorize와 @Secured의 차이점을 설명하세요.",
      "answer": "@PreAuthorize는 SpEL을 지원하여 복잡한 조건식 사용 가능하고, @Secured는 간단한 역할 기반 접근 제어만 지원합니다.",
      "explanation": "@PreAuthorize가 더 유연하며, 메서드 실행 전 권한을 체크합니다."
    },
    {
      "id": 96,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "Spring Security의 SecurityContextHolder가 기본적으로 사용하는 저장 전략은?",
      "choices": [
        "MODE_THREADLOCAL",
        "MODE_INHERITABLETHREADLOCAL",
        "MODE_GLOBAL",
        "MODE_SESSION"
      ],
      "answer": "MODE_THREADLOCAL",
      "explanation": "ThreadLocal을 사용하여 각 요청 스레드마다 독립적인 SecurityContext를 유지합니다."
    },
    {
      "id": 97,
      "type": "descriptive",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "Spring Security에서 OAuth2 Authorization Code Flow의 전체 과정을 설명하세요.",
      "answer": "1) 클라이언트가 Authorization Server로 인증 요청 → 2) 사용자 로그인 후 Authorization Code 발급 → 3) 클라이언트가 Code를 가지고 Access Token 요청 → 4) Authorization Server가 Access Token 발급 → 5) 클라이언트가 Token으로 Resource Server 접근 → 6) Token 만료 시 Refresh Token으로 재발급",
      "explanation": "Authorization Code 방식은 가장 안전하며, 서버 사이드 애플리케이션에 적합합니다."
    },
    {
      "id": 98,
      "type": "multiple_choice",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 PasswordEncoder의 기본 구현체는?",
      "choices": [
        "BCryptPasswordEncoder",
        "Pbkdf2PasswordEncoder",
        "SCryptPasswordEncoder",
        "DelegatingPasswordEncoder"
      ],
      "answer": "DelegatingPasswordEncoder",
      "explanation": "Spring Security 5부터 DelegatingPasswordEncoder가 기본이며, 여러 인코더를 지원하고 bcrypt를 기본값으로 사용합니다."
    },
    {
      "id": 99,
      "type": "short_answer",
      "category": "Spring Security",
      "difficulty": "intermediate",
      "question": "Spring Security에서 Remember-Me 기능의 동작 원리를 설명하세요.",
      "answer": "사용자가 로그인 시 Remember-Me 쿠키를 생성하여 브라우저에 저장하고, 세션 만료 후에도 쿠키로 자동 인증합니다. Token 기반 또는 Persistent 방식(DB 저장)을 선택할 수 있습니다.",
      "explanation": "편의성을 위해 사용되지만, 보안상 민감한 작업에서는 재인증을 요구하는 것이 좋습니다."
    },
    {
      "id": 100,
      "type": "descriptive",
      "category": "Spring Security",
      "difficulty": "advanced",
      "question": "Spring Security에서 Method Security를 활성화하고 사용하는 방법을 @EnableGlobalMethodSecurity와 함께 설명하세요.",
      "answer": "@EnableGlobalMethodSecurity(prePostEnabled=true, securedEnabled=true)를 설정 클래스에 추가하면, 메서드 레벨 보안이 활성화됩니다. prePostEnabled는 @PreAuthorize/@PostAuthorize를, securedEnabled는 @Secured를 활성화합니다. 이후 메서드에 애노테이션을 붙여 권한 기반 접근 제어를 구현할 수 있습니다.",
      "explanation": "Method Security는 서비스 레벨에서 세밀한 권한 제어를 가능하게 합니다."
    }
  ]
}